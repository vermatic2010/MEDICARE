{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\verma\\\\Downloads\\\\Medical Bot\\\\client\\\\src\\\\pages\\\\SmartTriage.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from \"react\";\nimport ChatWindow from \"../components/ChatWindow\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SmartTriage = ({\n  role = \"patient\",\n  user,\n  onNavigate\n}) => {\n  _s();\n  const [chat, setChat] = useState([{\n    sender: \"bot\",\n    text: role === \"doctor\" ? \"Welcome Doctor! Use the buttons below to view appointments, check symptoms, or upload a prescription. You can also type natural language requests like 'show patient 1 medicines' or 'check john's active prescriptions'. (ðŸ”¬ Symptom analysis uses RAG-enhanced medical knowledge!)\" : \"Welcome to Smart Triage! Use buttons below to start symptom checker, upload prescription, book appointment, view your appointments, or check prescription history. You can also type natural language requests like 'show my recent 3 prescriptions' or 'book appointment with cardiologist'. (ðŸ”¬ Symptom analysis uses RAG-enhanced medical knowledge!)\"\n  }]);\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n  const [awaitingSymptoms, setAwaitingSymptoms] = useState(false);\n  const [awaitingBooking, setAwaitingBooking] = useState(null);\n  const [suggestedSpecialist, setSuggestedSpecialist] = useState(null);\n  const [doctorListCache, setDoctorListCache] = useState(null);\n  const [awaitingMedicineInput, setAwaitingMedicineInput] = useState(false);\n  const [awaitingPatientId, setAwaitingPatientId] = useState(false);\n  const [awaitingPrescriptionChoice, setAwaitingPrescriptionChoice] = useState(false);\n\n  // Buttons for both doctor and patient\n  const commonButtons = [{\n    label: \"ðŸ©º Symptom Checker\",\n    type: \"symptom_checker\"\n  }, {\n    label: \"ðŸ“„ Upload Prescription\",\n    type: \"upload_prescription\"\n  }];\n  const patientButtons = [...commonButtons, {\n    label: \"ðŸ“… Book Appointment\",\n    type: \"book_appointment\"\n  }, {\n    label: \"ðŸ“‹ My Appointments\",\n    type: \"view_my_appointments\"\n  }, {\n    label: \"ðŸ“œ Prescription History\",\n    type: \"view_prescription_history\"\n  }];\n  const doctorButtons = [...commonButtons, {\n    label: \"ðŸ“† View Appointments\",\n    type: \"view_appointments\"\n  }, {\n    label: \"ðŸ’Š Add Medicine for Patient\",\n    type: \"add_medicine\"\n  }, {\n    label: \"ðŸ“‹ View Patient Medicine History\",\n    type: \"view_patient_medicines\"\n  }];\n  const buttons = role === \"doctor\" ? doctorButtons : patientButtons;\n\n  // Gemini AI-powered intent detection and entity extraction (NOT RAG - just parsing)\n  const geminiParseInput = async (input, context = \"general\") => {\n    try {\n      const response = await fetch(\"http://localhost:3001/api/ai-response\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          type: \"comprehensive-intent-extraction\",\n          userInput: input,\n          context: context // \"patient\", \"doctor\", or \"general\"\n        })\n      });\n      if (response.ok) {\n        const data = await response.json();\n        const cleanResponse = data.response.replace(/```json|```/g, '').trim();\n        try {\n          return JSON.parse(cleanResponse);\n        } catch (parseError) {\n          console.log(\"Failed to parse Gemini response:\", parseError);\n          return null;\n        }\n      }\n    } catch (error) {\n      console.log(\"Gemini parsing failed:\", error);\n    }\n    return null;\n  };\n\n  // Enhanced intent detection with comprehensive Gemini AI support\n  const detectIntent = async input => {\n    const text = input.toLowerCase();\n\n    // Use Gemini for comprehensive intent and entity extraction\n    const geminiResult = await geminiParseInput(input, role);\n    if (geminiResult) {\n      // Handle complex extracted intents\n      switch (geminiResult.intent) {\n        case \"prescription_history\":\n          return {\n            type: \"view_prescription_history\",\n            count: geminiResult.count,\n            timeframe: geminiResult.timeframe\n          };\n        case \"book_appointment\":\n          return {\n            type: \"book_appointment\",\n            doctor_id: geminiResult.doctor_id,\n            specialist: geminiResult.specialist,\n            date: geminiResult.date,\n            time: geminiResult.time\n          };\n        case \"patient_lookup\":\n          return {\n            type: geminiResult.action || \"view_patient_medicines\",\n            patient_identifier: geminiResult.patient_identifier,\n            patient_type: geminiResult.patient_type\n          };\n        case \"medicine_add\":\n          return {\n            type: \"add_medicine\",\n            patient_identifier: geminiResult.patient_identifier,\n            medicines: geminiResult.medicines\n          };\n        case \"symptom_check\":\n          return {\n            type: \"symptom_checker\",\n            symptoms: geminiResult.symptoms\n          };\n        case \"appointment_view\":\n          return {\n            type: geminiResult.target === \"doctor\" ? \"view_appointments\" : \"view_my_appointments\"\n          };\n        default:\n          // Map other intents to existing types\n          if (geminiResult.intent) {\n            return {\n              type: geminiResult.intent\n            };\n          }\n      }\n    }\n\n    // Fallback to quick regex-based detection for common patterns\n    if (/book.*appointment/.test(text)) return {\n      type: \"book_appointment\"\n    };\n    if (/view.*appointment/.test(text) || /my.*appointment/.test(text)) return {\n      type: \"view_my_appointments\"\n    };\n    if (/symptom|check.*symptom/.test(text)) return {\n      type: \"symptom_checker\"\n    };\n    if (/upload.*prescription/.test(text)) return {\n      type: \"upload_prescription\"\n    };\n    if (/patient.*medicine|medicine.*history|patient.*prescription/.test(text)) return {\n      type: \"view_patient_medicines\"\n    };\n\n    // Enhanced prescription history detection with number parsing\n    const prescriptionPatterns = [/prescription.*list|last.*prescription|prescription.*history/, /recent.*prescription|latest.*prescription/, /my.*prescription|get.*prescription|fetch.*prescription/, /show.*prescription|list.*prescription/];\n    if (prescriptionPatterns.some(pattern => pattern.test(text))) {\n      return {\n        type: \"view_prescription_history\"\n      };\n    }\n    return null;\n  };\n\n  // TRUE RAG: analyzeSymptoms uses medical knowledge database\n  const analyzeSymptoms = async symptoms => {\n    try {\n      setIsAnalyzing(true);\n      setAwaitingSymptoms(false);\n      setChat(prev => [...prev, {\n        sender: \"bot\",\n        text: \"Analyzing your symptoms...\",\n        isLoading: true\n      }]);\n      const response = await fetch(\"http://localhost:3001/api/ai-response\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          type: \"symptom-specialist\",\n          userInput: `Given these symptoms: \"${symptoms}\", what are the possible diseases and which specialist should the patient consult? Respond with:\\nPossible diseases: <list>\\nRecommended specialist: <specialist>\\nIf serious, add: \"Would you like to book an appointment with a <specialist>? (Type yes to proceed)\"`\n        })\n      });\n      if (!response.ok) throw new Error(\"Failed to analyze symptoms\");\n      const data = await response.json();\n      let analysisText = data.response.replace(/\\n/g, \"\\n\");\n      const specialistMatch = analysisText.match(/Recommended specialist:\\s*([^\\n]+)/i);\n      let specialist = null;\n      if (specialistMatch) {\n        specialist = specialistMatch[1].trim();\n        setSuggestedSpecialist(specialist);\n      } else {\n        setSuggestedSpecialist(null);\n      }\n      if (/would you like to book an appointment/i.test(analysisText) && specialist) {\n        setAwaitingBooking(specialist);\n      } else {\n        setAwaitingBooking(null);\n      }\n      setChat(prev => [...prev.filter(msg => !msg.isLoading), {\n        sender: \"bot\",\n        text: analysisText\n      }]);\n    } catch (error) {\n      setChat(prev => [...prev.filter(msg => !msg.isLoading), {\n        sender: \"bot\",\n        text: \"Sorry, I couldn't analyze your symptoms right now. Please try again later.\"\n      }]);\n      console.error(\"Analysis error:\", error);\n    } finally {\n      setIsAnalyzing(false);\n    }\n  };\n\n  // STRUCTURED PROMPTING: prescription explanation (NOT RAG - just AI parsing)\n  const explainPrescription = async prescriptionText => {\n    try {\n      setIsAnalyzing(true);\n      setChat(prev => [...prev, {\n        sender: \"bot\",\n        text: \"Explaining your prescription...\",\n        isLoading: true\n      }]);\n      const response = await fetch(\"http://localhost:3001/api/ai-response\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          type: \"prescription\",\n          userInput: `Explain this prescription in simple terms for a patient:\\n${prescriptionText}`\n        })\n      });\n      if (!response.ok) throw new Error(\"Failed to analyze prescription\");\n      const data = await response.json();\n      setChat(prev => [...prev.filter(msg => !msg.isLoading), {\n        sender: \"bot\",\n        text: `ðŸ“ Prescription explained:\\n\\n${data.response.replace(/\\n/g, \"\\n\")}`\n      }]);\n    } catch (error) {\n      setChat(prev => [...prev.filter(msg => !msg.isLoading), {\n        sender: \"bot\",\n        text: \"Sorry, I couldn't analyze your prescription right now. Please try again later.\"\n      }]);\n      console.error(\"Prescription analysis error:\", error);\n    } finally {\n      setIsAnalyzing(false);\n    }\n  };\n\n  // Handle file upload for prescriptions\n  const handleFileUpload = async file => {\n    if (!file) return;\n\n    // Validate file type\n    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/bmp', 'application/pdf', 'text/plain'];\n    if (!allowedTypes.includes(file.type)) {\n      setChat(prev => [...prev, {\n        sender: \"bot\",\n        text: \"âŒ Unsupported file type. Please upload an image (JPG, PNG), PDF, or text file.\"\n      }]);\n      return;\n    }\n\n    // Check file size (max 10MB)\n    if (file.size > 10 * 1024 * 1024) {\n      setChat(prev => [...prev, {\n        sender: \"bot\",\n        text: \"âŒ File too large. Please upload a file smaller than 10MB.\"\n      }]);\n      return;\n    }\n    try {\n      setIsAnalyzing(true);\n      setChat(prev => [...prev, {\n        sender: \"user\",\n        text: `ðŸ“Ž Uploaded: ${file.name}`\n      }, {\n        sender: \"bot\",\n        text: \"ðŸ“‹ Analyzing your medical document...\",\n        isLoading: true\n      }]);\n      const formData = new FormData();\n      formData.append('file', file);\n      formData.append('type', 'prescription');\n      const response = await fetch(\"http://localhost:3001/api/ai-response\", {\n        method: \"POST\",\n        body: formData\n      });\n      if (!response.ok) throw new Error(\"Failed to analyze document\");\n      const data = await response.json();\n      setChat(prev => [...prev.filter(msg => !msg.isLoading), {\n        sender: \"bot\",\n        text: `ðŸ“‹ **Medical Document Analysis:**\\n\\n${data.response}`\n      }]);\n    } catch (error) {\n      setChat(prev => [...prev.filter(msg => !msg.isLoading), {\n        sender: \"bot\",\n        text: \"âŒ Failed to analyze the document. Please try again or type the prescription text manually.\"\n      }]);\n      console.error(\"File upload error:\", error);\n    } finally {\n      setIsAnalyzing(false);\n    }\n  };\n\n  // Main user input handler\n  const handleUserInput = async (input, fromUser = true) => {\n    if (fromUser) {\n      if (typeof input === \"string\") {\n        setChat(prev => [...prev, {\n          sender: \"user\",\n          text: input\n        }]);\n      } else if (input && input.label) {\n        setChat(prev => [...prev, {\n          sender: \"user\",\n          text: input.label\n        }]);\n      }\n    }\n\n    // Handle button actions\n    if (input && input.type) {\n      // Reset states when new button is clicked\n      setAwaitingSymptoms(false);\n      setAwaitingMedicineInput(false);\n      setAwaitingPatientId(false);\n      setAwaitingPrescriptionChoice(false);\n      switch (input.type) {\n        case \"symptom_checker\":\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: \"Please describe your symptoms in detail.\"\n          }]);\n          setAwaitingSymptoms(true);\n          return;\n        case \"upload_prescription\":\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: \"Please upload your prescription or medical document. I can analyze:\\n\\nðŸ“‹ Images (JPG, PNG, etc.)\\nðŸ“„ PDF documents\\nðŸ“ Text files\\n\\nOr you can type the prescription text directly.\",\n            showFileUpload: true\n          }]);\n          return;\n        case \"view_my_appointments\":\n          try {\n            const patient_id = (user === null || user === void 0 ? void 0 : user.id) || 1;\n            const response = await fetch(`http://localhost:3001/api/patients/appointments/${patient_id}`);\n            const data = await response.json();\n\n            // Handle MCP-style response\n            const appointments = data.appointments || [];\n            if (appointments.length > 0) {\n              const appointmentsList = appointments.map(appt => {\n                const date = new Date(appt.appointment_time);\n                return `ðŸ“… ${date.toLocaleDateString()} at ${date.toLocaleTimeString()} with Dr. ${appt.doctor_name}`;\n              }).join('\\n');\n              setChat(prev => [...prev, {\n                sender: \"bot\",\n                text: `Your upcoming appointments:\\n\\n${appointmentsList}`\n              }]);\n            } else {\n              setChat(prev => [...prev, {\n                sender: \"bot\",\n                text: data.message || \"You have no upcoming appointments.\"\n              }]);\n            }\n          } catch (error) {\n            console.error(\"Error fetching appointments:\", error);\n            setChat(prev => [...prev, {\n              sender: \"bot\",\n              text: \"Error fetching appointments. Please try again later.\"\n            }]);\n          }\n          return;\n        case \"view_prescription_history\":\n          // Check if we have enhanced parameters from Gemini\n          if (input.count || input.timeframe) {\n            await handlePrescriptionHistoryWithParams(input.count, input.timeframe);\n          } else {\n            // Default behavior - ask user for choice\n            setChat(prev => [...prev, {\n              sender: \"user\",\n              text: \"You chose Prescription History\"\n            }, {\n              sender: \"bot\",\n              text: \"Would you like to see:\\n\\nðŸ“‹ **All** prescriptions\\nðŸ•’ **Recent** prescriptions (last 10)\\n\\nPlease type 'all' or 'recent':\"\n            }]);\n            setAwaitingPrescriptionChoice(true);\n          }\n          return;\n        case \"book_appointment\":\n          await handleAppointmentBooking(input.specialist);\n          return;\n        case \"view_appointments\":\n          // Doctor view appointments - MCP style\n          try {\n            const doctor_id = (user === null || user === void 0 ? void 0 : user.id) || 1;\n            const response = await fetch(`http://localhost:3001/api/doctors/appointments/${doctor_id}`);\n            const data = await response.json();\n\n            // Handle MCP-style response\n            const appointments = data.appointments || [];\n            if (appointments.length > 0) {\n              const appointmentsList = appointments.map(appt => {\n                const date = new Date(appt.appointment_time);\n                return `ðŸ“… ${date.toLocaleDateString()} at ${date.toLocaleTimeString()} with ${appt.patient_name}`;\n              }).join('\\n');\n              setChat(prev => [...prev, {\n                sender: \"bot\",\n                text: `Your appointments:\\n\\n${appointmentsList}`\n              }]);\n            } else {\n              setChat(prev => [...prev, {\n                sender: \"bot\",\n                text: data.message || \"You have no scheduled appointments.\"\n              }]);\n            }\n          } catch (error) {\n            console.error(\"Error fetching appointments:\", error);\n            setChat(prev => [...prev, {\n              sender: \"bot\",\n              text: \"Error fetching appointments. Please try again later.\"\n            }]);\n          }\n          return;\n        case \"add_medicine\":\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: \"Please enter medicines in this format:\\nPatient Username: [username]\\nMedicines:\\n- [Medicine Name], [Dosage], [Duration], [Instructions]\\n- [Medicine Name], [Dosage], [Duration], [Instructions]\\n\\nExample (with dashes):\\nPatient Username: mrigankshekharverma\\nMedicines:\\n- Paracetamol, 500mg, 5 days, Take twice daily after meals\\n- Vitamin D3, 1000 IU, 30 days, Take once daily with breakfast\\n\\nExample (without dashes also works):\\nPatient Username: mrigankshekharverma\\nMedicines:\\nParacetamol, 500mg, 5 days, Take twice daily after meals\\nVitamin D3, 1000 IU, 30 days, Take once daily with breakfast\"\n          }]);\n          setAwaitingMedicineInput(true);\n          return;\n        case \"view_patient_medicines\":\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: \"Please enter the patient's username or patient ID to view their medicine history:\"\n          }]);\n          setAwaitingPatientId(true);\n          return;\n      }\n    }\n\n    // Handle prescription choice (all or recent)\n    if (awaitingPrescriptionChoice && typeof input === \"string\") {\n      setAwaitingPrescriptionChoice(false);\n      const choice = input.toLowerCase().trim();\n      if (choice === \"all\" || choice === \"recent\") {\n        try {\n          const patient_id = (user === null || user === void 0 ? void 0 : user.id) || 1;\n          const limit = choice === \"all\" ? 1000 : 10;\n          const response = await fetch(`http://localhost:3001/api/patients/${patient_id}/prescription-history?limit=${limit}`);\n          const data = await response.json();\n\n          // Handle MCP-style response\n          const prescriptions = data.prescriptions || [];\n          if (prescriptions.length > 0) {\n            const prescriptionsList = prescriptions.map(presc => {\n              const date = new Date(presc.prescribed_date);\n              const doctorName = presc.doctor_name ? `by Dr. ${presc.doctor_name}` : 'by Unknown Doctor';\n              return `ðŸ“œ ${presc.medicine_name} (${presc.dosage}) - ${presc.duration}\\n   Prescribed on ${date.toLocaleDateString()} ${doctorName}\\n   Status: ${presc.status}`;\n            }).join('\\n\\n');\n            const displayText = choice === \"all\" ? `All your prescriptions (${prescriptions.length} total):\\n\\n${prescriptionsList}` : `Your recent prescriptions (last ${prescriptions.length}):\\n\\n${prescriptionsList}`;\n            setChat(prev => [...prev, {\n              sender: \"bot\",\n              text: displayText\n            }]);\n          } else {\n            setChat(prev => [...prev, {\n              sender: \"bot\",\n              text: data.message || \"No prescription history found.\"\n            }]);\n          }\n        } catch (error) {\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: \"Error fetching prescription history.\"\n          }]);\n        }\n      } else {\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: \"Please type 'all' or 'recent' to choose what prescriptions to view.\"\n        }]);\n        setAwaitingPrescriptionChoice(true);\n      }\n      return;\n    }\n\n    // Handle medicine input for doctors - MCP style\n    if (awaitingMedicineInput && typeof input === \"string\") {\n      setAwaitingMedicineInput(false);\n      try {\n        // Parse the new format\n        const lines = input.trim().split('\\n');\n        const patientUsernameLine = lines.find(line => line.toLowerCase().includes('patient username'));\n        if (!patientUsernameLine) {\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: \"Please include 'Patient Username: [username]' in your input.\"\n          }]);\n          return;\n        }\n        const patientUsername = patientUsernameLine.split(':')[1].trim();\n        if (!patientUsername) {\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: \"Please provide a valid patient username.\"\n          }]);\n          return;\n        }\n\n        // Extract medicine lines (lines starting with - OR valid medicine format)\n        let medicineLines = lines.filter(line => line.trim().startsWith('-'));\n\n        // Also check for medicine-like lines without dashes\n        const potentialMedicineLines = lines.filter(line => {\n          const trimmed = line.trim();\n          return trimmed.length > 0 && !trimmed.toLowerCase().includes('patient username') && !trimmed.toLowerCase().includes('medicines:') && !trimmed.startsWith('-') &&\n          // Not already processed\n          trimmed.includes(',') && trimmed.split(',').length >= 3; // At least name, dosage, duration\n        });\n        if (potentialMedicineLines.length > 0) {\n          // Add non-dashed medicine lines, prefixed with dashes for processing\n          medicineLines = medicineLines.concat(potentialMedicineLines.map(line => `- ${line.trim()}`));\n        }\n        if (medicineLines.length === 0) {\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: \"Please include at least one medicine in the correct format.\\n\\nExample:\\n- Paracetamol, 500mg, 5 days, Take twice daily after meals\\n\\nOr without dashes:\\nParacetamol, 500mg, 5 days, Take twice daily after meals\"\n          }]);\n          return;\n        }\n\n        // Parse each medicine BEFORE patient lookup\n        const medicines = [];\n        for (const line of medicineLines) {\n          const parts = line.substring(1).split(',').map(s => s.trim()); // Remove '-' and split\n          if (parts.length >= 3) {\n            medicines.push({\n              name: parts[0],\n              dosage: parts[1],\n              duration: parts[2],\n              instructions: parts[3] || \"As prescribed by doctor\"\n            });\n          }\n        }\n        if (medicines.length === 0) {\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: \"Please use correct format: - Medicine Name, Dosage, Duration, Instructions\"\n          }]);\n          return;\n        }\n\n        // NOW do patient lookup after validating format\n        const lookupResponse = await fetch(`http://localhost:3001/api/patients/lookup/${patientUsername}`);\n        const lookupData = await lookupResponse.json();\n        if (!lookupResponse.ok || lookupData.context.status !== \"found\") {\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: `Patient not found with username: ${patientUsername}. Please check the username and try again.`\n          }]);\n          return;\n        }\n        const patientId = lookupData.patient.id;\n        const patientName = lookupData.patient.full_name;\n\n        // Add each medicine\n        let successCount = 0;\n        let failCount = 0;\n        const results = [];\n        for (const medicine of medicines) {\n          try {\n            const response = await fetch(\"http://localhost:3001/api/prescriptions/add\", {\n              method: \"POST\",\n              headers: {\n                \"Content-Type\": \"application/json\"\n              },\n              body: JSON.stringify({\n                context: {\n                  patient_id: patientId,\n                  doctor_id: (user === null || user === void 0 ? void 0 : user.id) || 1,\n                  medicine_name: medicine.name,\n                  dosage: medicine.dosage,\n                  duration: medicine.duration,\n                  instructions: medicine.instructions\n                }\n              })\n            });\n            const data = await response.json();\n            if (data.context && data.context.status === \"prescribed\") {\n              successCount++;\n              results.push(`âœ… ${medicine.name} - Added successfully`);\n            } else {\n              failCount++;\n              results.push(`âŒ ${medicine.name} - ${data.error || \"Failed to add\"}`);\n            }\n          } catch (error) {\n            failCount++;\n            results.push(`âŒ ${medicine.name} - Error adding medicine`);\n          }\n        }\n        const summary = `Added ${successCount} medicine(s) for ${patientName} (${patientUsername})${failCount > 0 ? `, ${failCount} failed` : ''}:\\n\\n${results.join('\\n')}`;\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: summary\n        }]);\n      } catch (error) {\n        // Fallback to old format for backward compatibility\n        const [patientIdOrUsername, name, dosage, duration] = input.split(\",\").map(s => s.trim());\n\n        // Check if it's a number (old format) or username (new format)\n        const isNumeric = !isNaN(patientIdOrUsername);\n        let patientId;\n        if (isNumeric) {\n          // Old format with patient ID\n          patientId = parseInt(patientIdOrUsername);\n        } else {\n          // Try to lookup username\n          try {\n            const lookupResponse = await fetch(`http://localhost:3001/api/patients/lookup/${patientIdOrUsername}`);\n            const lookupData = await lookupResponse.json();\n            if (!lookupResponse.ok || lookupData.context.status !== \"found\") {\n              setChat(prev => [...prev, {\n                sender: \"bot\",\n                text: `Patient not found: ${patientIdOrUsername}. Please check the format.`\n              }]);\n              return;\n            }\n            patientId = lookupData.patient.id;\n          } catch (lookupError) {\n            setChat(prev => [...prev, {\n              sender: \"bot\",\n              text: \"Failed to lookup patient. Please check the format.\"\n            }]);\n            return;\n          }\n        }\n        try {\n          const response = await fetch(\"http://localhost:3001/api/prescriptions/add\", {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n              context: {\n                patient_id: patientId,\n                doctor_id: (user === null || user === void 0 ? void 0 : user.id) || 1,\n                medicine_name: name,\n                dosage: dosage,\n                duration: duration,\n                instructions: \"As prescribed by doctor\"\n              }\n            })\n          });\n          const data = await response.json();\n          if (data.context && data.context.status === \"prescribed\") {\n            setChat(prev => [...prev, {\n              sender: \"bot\",\n              text: data.message || \"Medicine added for patient.\"\n            }]);\n          } else {\n            setChat(prev => [...prev, {\n              sender: \"bot\",\n              text: data.error || \"Failed to add medicine.\"\n            }]);\n          }\n        } catch (fallbackError) {\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: \"Failed to add medicine. Please check the format.\"\n          }]);\n        }\n      }\n      return;\n    }\n\n    // Handle patient username input for viewing medicine history with enhanced NLP\n    if (awaitingPatientId && typeof input === \"string\") {\n      setAwaitingPatientId(false);\n      let patientInput = input.trim();\n\n      // Try to extract patient identifier using Gemini for natural language\n      if (!/^\\d+$/.test(patientInput) && !patientInput.includes('@') && patientInput.length > 3) {\n        try {\n          const response = await fetch(\"http://localhost:3001/api/ai-response\", {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n              type: \"patient-extraction\",\n              userInput: `Extract patient identifier from: \"${input}\"\\n\\nRespond with ONLY a JSON object:\\n{\\n  \"patient_identifier\": \"username_or_id\",\\n  \"type\": \"username|id|unknown\"\\n}\\n\\nExamples:\\n- \"patient john doe\" -> {\"patient_identifier\": \"johndoe\", \"type\": \"username\"}\\n- \"user mrigank\" -> {\"patient_identifier\": \"mrigank\", \"type\": \"username\"}\\n- \"patient id 5\" -> {\"patient_identifier\": \"5\", \"type\": \"id\"}\\n- \"123\" -> {\"patient_identifier\": \"123\", \"type\": \"id\"}`\n            })\n          });\n          if (response.ok) {\n            const data = await response.json();\n            const cleanResponse = data.response.replace(/```json|```/g, '').trim();\n            try {\n              const parsed = JSON.parse(cleanResponse);\n              if (parsed.patient_identifier && parsed.type !== \"unknown\") {\n                patientInput = parsed.patient_identifier;\n              }\n            } catch (parseError) {\n              console.log(\"Failed to parse patient extraction:\", parseError);\n            }\n          }\n        } catch (error) {\n          console.log(\"Gemini patient extraction failed:\", error);\n        }\n      }\n      if (!patientInput) {\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: \"Please enter a valid patient username or ID.\"\n        }]);\n        return;\n      }\n      try {\n        let patientId, patientName;\n\n        // Check if input is a number (patient ID) or username\n        if (/^\\d+$/.test(patientInput)) {\n          // Input is a number, treat as patient ID\n          patientId = parseInt(patientInput, 10);\n\n          // Fetch patient details by ID\n          const patientResponse = await fetch(`http://localhost:3001/api/patients/${patientId}`);\n          const patientData = await patientResponse.json();\n          if (!patientResponse.ok || !patientData.patient) {\n            setChat(prev => [...prev, {\n              sender: \"bot\",\n              text: `Patient not found with ID: ${patientId}. Please check the ID and try again.`\n            }]);\n            return;\n          }\n          patientName = patientData.patient.full_name;\n        } else {\n          // Input is a username, lookup patient ID from username\n          const lookupResponse = await fetch(`http://localhost:3001/api/patients/lookup/${patientInput}`);\n          const lookupData = await lookupResponse.json();\n          if (!lookupResponse.ok || lookupData.context.status !== \"found\") {\n            setChat(prev => [...prev, {\n              sender: \"bot\",\n              text: `Patient not found with username: ${patientInput}. Please check the username and try again.`\n            }]);\n            return;\n          }\n          patientId = lookupData.patient.id;\n          patientName = lookupData.patient.full_name;\n        }\n\n        // Now fetch prescription history\n        const response = await fetch(`http://localhost:3001/api/patients/${patientId}/prescription-history`);\n        const data = await response.json();\n\n        // Handle MCP-style response\n        const prescriptions = data.prescriptions || [];\n        if (prescriptions.length > 0) {\n          const prescriptionsList = prescriptions.map(presc => {\n            const date = new Date(presc.prescribed_date);\n            const doctorName = presc.doctor_name ? `by Dr. ${presc.doctor_name}` : 'by Unknown Doctor';\n            return `ðŸ“œ ${presc.medicine_name} (${presc.dosage}) - ${presc.duration}\\n   Prescribed on ${date.toLocaleDateString()} ${doctorName}\\n   Status: ${presc.status}\\n   Instructions: ${presc.instructions || 'None'}`;\n          }).join('\\n\\n');\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: `Medicine history for ${patientName} (${/^\\d+$/.test(patientInput) ? `ID: ${patientInput}` : patientInput}):\\n\\n${prescriptionsList}`\n          }]);\n        } else {\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: data.message || `No prescription history found for ${patientName} (${/^\\d+$/.test(patientInput) ? `ID: ${patientInput}` : patientInput}).`\n          }]);\n        }\n      } catch (error) {\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: `Error fetching medicine history for patient: ${patientInput}.`\n        }]);\n      }\n      return;\n    }\n\n    // Handle simple number input for doctor selection (when doctor list is shown)\n    if (typeof input === \"string\" && /^\\d+$/.test(input.trim()) && doctorListCache) {\n      const doctorId = parseInt(input.trim(), 10);\n      const doctor = doctorListCache.find(d => d.id === doctorId);\n      if (doctor) {\n        // Show doctor details and ask for appointment details\n        let availabilityText = \"\";\n        if (doctor.slots && Object.keys(doctor.slots).length > 0) {\n          const availableDays = Object.keys(doctor.slots).filter(day => doctor.slots[day] && doctor.slots[day].length > 0).map(day => {\n            const slots = doctor.slots[day];\n            const timeSlots = slots.map(s => s.time).join(\", \");\n            return `${day}: ${timeSlots}`;\n          });\n          availabilityText = availableDays.length > 0 ? `\\n\\nAvailable slots:\\n${availableDays.join(\"\\n\")}` : \"\\nNo availability set\";\n        }\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: `You selected Dr. ${doctor.full_name} (${doctor.specialization})${availabilityText}\\n\\nTo book an appointment, type:\\n\"book my appointment for doctor id ${doctor.id} on YYYY-MM-DD, HH:MM AM/PM\"\\n\\nExample: \"book my appointment for doctor id ${doctor.id} on 2025-07-15, 10:00 AM\"`\n        }]);\n        return;\n      } else {\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: `Doctor with ID ${doctorId} not found in the current list. Please choose from the available doctors above.`\n        }]);\n        return;\n      }\n    }\n\n    // Handle appointment booking by doctor ID and slot (supports \"5PM\", \"5 PM\", \"5:00PM\", etc.)\n    const bookingRegex = /book.*appointment.*doctor\\s*id\\s*(\\d+).*on\\s*(\\d{4}-\\d{2}-\\d{2})\\s*,?\\s*(\\d{1,2}(?::\\d{2})?\\s*(?:AM|PM))/i;\n    const bookingMatch = typeof input === \"string\" && input.match(bookingRegex);\n    if (bookingMatch) {\n      await handleDirectBooking(bookingMatch);\n      return;\n    }\n\n    // Handle awaiting booking confirmation\n    if (awaitingBooking && typeof input === \"string\") {\n      const answer = input.trim().toLowerCase();\n      if (answer === \"yes\" && suggestedSpecialist) {\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: `Booking an appointment with a ${suggestedSpecialist} for you...`\n        }]);\n        await handleAppointmentBooking(suggestedSpecialist);\n        setAwaitingBooking(null);\n        setSuggestedSpecialist(null);\n        return;\n      }\n      if (answer === \"no\") {\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: \"Okay, I won't book an appointment. If you need anything else, just let me know!\"\n        }]);\n        setAwaitingBooking(null);\n        setSuggestedSpecialist(null);\n        return;\n      }\n    }\n\n    // Handle awaiting symptoms\n    if (awaitingSymptoms) {\n      await analyzeSymptoms(input);\n      return;\n    }\n\n    // Symptom keyword detection\n    const symptomKeywords = [\"fever\", \"cough\", \"cold\", \"headache\", \"pain\", \"sore throat\", \"vomit\", \"nausea\", \"diarrhea\", \"chills\", \"fatigue\", \"rash\", \"dizzy\", \"breath\", \"congestion\"];\n    const lower = typeof input === \"string\" ? input.toLowerCase() : \"\";\n    if (symptomKeywords.some(kw => lower.includes(kw))) {\n      await analyzeSymptoms(input);\n      return;\n    }\n\n    // Prescription text detection\n    const prescriptionKeywords = [\"tablet\", \"capsule\", \"syrup\", \"medicine\", \"drug\", \"prescription\", \"dosage\", \"take\", \"mg\", \"ml\", \"twice daily\", \"once daily\", \"before meals\", \"after meals\"];\n    if (typeof input === \"string\" && prescriptionKeywords.some(kw => lower.includes(kw))) {\n      await explainPrescription(input);\n      return;\n    }\n\n    // Enhanced natural language processing with comprehensive Gemini parsing\n    if (typeof input === \"string\") {\n      // Get comprehensive parsing from Gemini\n      const geminiResult = await geminiParseInput(input, role);\n      if (geminiResult) {\n        // Handle direct medicine addition with extracted data\n        if (geminiResult.intent === \"medicine_add\" && geminiResult.patient_identifier && geminiResult.medicines) {\n          await handleMedicineAdditionFromGemini(geminiResult);\n          return;\n        }\n\n        // Handle patient lookup with extracted data\n        if (geminiResult.intent === \"patient_lookup\" && geminiResult.patient_identifier) {\n          await handlePatientLookupFromGemini(geminiResult);\n          return;\n        }\n\n        // Handle direct appointment booking with full details\n        if (geminiResult.intent === \"book_appointment\" && geminiResult.doctor_id && geminiResult.date && geminiResult.time) {\n          const bookingMatch = [null, geminiResult.doctor_id.toString(), geminiResult.date, geminiResult.time];\n          await handleDirectBooking(bookingMatch);\n          return;\n        }\n\n        // Handle symptom analysis with extracted symptoms\n        if (geminiResult.intent === \"symptom_check\" && geminiResult.symptoms) {\n          await analyzeSymptoms(geminiResult.symptoms);\n          return;\n        }\n\n        // Handle prescription history with extracted parameters\n        if (geminiResult.intent === \"prescription_history\") {\n          await handlePrescriptionHistoryWithParams(geminiResult.count, geminiResult.timeframe);\n          return;\n        }\n      }\n\n      // Enhanced intent detection for text input\n      const intentResult = await detectIntent(input);\n      if (intentResult) {\n        await handleUserInput(intentResult, false);\n        return;\n      }\n    }\n\n    // Default response\n    setChat(prev => [...prev, {\n      sender: \"bot\",\n      text: \"How can I help you today? You can:\\nâ€¢ Use the buttons below\\nâ€¢ Describe your symptoms\\nâ€¢ Type natural language requests like:\\n  - 'show my recent 5 prescriptions'\\n  - 'book appointment with cardiologist'\\n  - 'get patient john's medicine history'\"\n    }]);\n  };\n\n  // Helper function to handle medicine addition from Gemini extraction\n  const handleMedicineAdditionFromGemini = async geminiResult => {\n    try {\n      const {\n        patient_identifier,\n        medicines\n      } = geminiResult;\n\n      // Resolve patient\n      let patientId, patientName;\n      if (/^\\d+$/.test(patient_identifier)) {\n        const patientResponse = await fetch(`http://localhost:3001/api/patients/${patient_identifier}`);\n        const patientData = await patientResponse.json();\n        if (!patientResponse.ok || !patientData.patient) {\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: `Patient not found with ID: ${patient_identifier}`\n          }]);\n          return;\n        }\n        patientId = parseInt(patient_identifier);\n        patientName = patientData.patient.full_name;\n      } else {\n        const lookupResponse = await fetch(`http://localhost:3001/api/patients/lookup/${patient_identifier}`);\n        const lookupData = await lookupResponse.json();\n        if (!lookupResponse.ok || lookupData.context.status !== \"found\") {\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: `Patient not found: ${patient_identifier}`\n          }]);\n          return;\n        }\n        patientId = lookupData.patient.id;\n        patientName = lookupData.patient.full_name;\n      }\n\n      // Add medicines\n      let successCount = 0;\n      let failCount = 0;\n      const results = [];\n      for (const medicine of medicines) {\n        try {\n          const response = await fetch(\"http://localhost:3001/api/prescriptions/add\", {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n              context: {\n                patient_id: patientId,\n                doctor_id: (user === null || user === void 0 ? void 0 : user.id) || 1,\n                medicine_name: medicine.name,\n                dosage: medicine.dosage,\n                duration: medicine.duration,\n                instructions: medicine.instructions || \"As prescribed by doctor\"\n              }\n            })\n          });\n          const data = await response.json();\n          if (data.context && data.context.status === \"prescribed\") {\n            successCount++;\n            results.push(`âœ… ${medicine.name} - Added successfully`);\n          } else {\n            failCount++;\n            results.push(`âŒ ${medicine.name} - ${data.error || \"Failed to add\"}`);\n          }\n        } catch (error) {\n          failCount++;\n          results.push(`âŒ ${medicine.name} - Error adding medicine`);\n        }\n      }\n      const summary = `Added ${successCount} medicine(s) for ${patientName} (${patient_identifier})${failCount > 0 ? `, ${failCount} failed` : ''}:\\n\\n${results.join('\\n')}`;\n      setChat(prev => [...prev, {\n        sender: \"bot\",\n        text: summary\n      }]);\n    } catch (error) {\n      setChat(prev => [...prev, {\n        sender: \"bot\",\n        text: \"Error processing medicine addition.\"\n      }]);\n    }\n  };\n\n  // Helper function to handle patient lookup from Gemini extraction\n  const handlePatientLookupFromGemini = async geminiResult => {\n    try {\n      const {\n        patient_identifier,\n        action = \"view_patient_medicines\"\n      } = geminiResult;\n\n      // Resolve patient\n      let patientId, patientName;\n      if (/^\\d+$/.test(patient_identifier)) {\n        const patientResponse = await fetch(`http://localhost:3001/api/patients/${patient_identifier}`);\n        const patientData = await patientResponse.json();\n        if (!patientResponse.ok || !patientData.patient) {\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: `Patient not found with ID: ${patient_identifier}`\n          }]);\n          return;\n        }\n        patientId = parseInt(patient_identifier);\n        patientName = patientData.patient.full_name;\n      } else {\n        const lookupResponse = await fetch(`http://localhost:3001/api/patients/lookup/${patient_identifier}`);\n        const lookupData = await lookupResponse.json();\n        if (!lookupResponse.ok || lookupData.context.status !== \"found\") {\n          setChat(prev => [...prev, {\n            sender: \"bot\",\n            text: `Patient not found: ${patient_identifier}`\n          }]);\n          return;\n        }\n        patientId = lookupData.patient.id;\n        patientName = lookupData.patient.full_name;\n      }\n\n      // Execute the requested action - show medicine history\n      const response = await fetch(`http://localhost:3001/api/patients/${patientId}/prescription-history`);\n      const data = await response.json();\n      const prescriptions = data.prescriptions || [];\n      if (prescriptions.length > 0) {\n        const prescriptionsList = prescriptions.map(presc => {\n          const date = new Date(presc.prescribed_date);\n          const doctorName = presc.doctor_name ? `by Dr. ${presc.doctor_name}` : 'by Unknown Doctor';\n          return `ðŸ“œ ${presc.medicine_name} (${presc.dosage}) - ${presc.duration}\\n   Prescribed on ${date.toLocaleDateString()} ${doctorName}\\n   Status: ${presc.status}\\n   Instructions: ${presc.instructions || 'None'}`;\n        }).join('\\n\\n');\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: `Medicine history for ${patientName} (${patient_identifier}):\\n\\n${prescriptionsList}`\n        }]);\n      } else {\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: `No prescription history found for ${patientName} (${patient_identifier}).`\n        }]);\n      }\n    } catch (error) {\n      setChat(prev => [...prev, {\n        sender: \"bot\",\n        text: \"Error processing patient lookup.\"\n      }]);\n    }\n  };\n\n  // Helper function to handle prescription history with specific parameters\n  const handlePrescriptionHistoryWithParams = async (count, timeframe) => {\n    try {\n      const patient_id = (user === null || user === void 0 ? void 0 : user.id) || 1;\n\n      // Determine limit based on parameters\n      let limit;\n      if (count) {\n        limit = parseInt(count, 10);\n      } else if (timeframe === \"all\") {\n        limit = 1000;\n      } else {\n        limit = 10; // default for \"recent\" or null\n      }\n\n      // Ensure reasonable limits\n      if (limit > 100) limit = 100;\n      if (limit < 1) limit = 10;\n      const response = await fetch(`http://localhost:3001/api/patients/${patient_id}/prescription-history?limit=${limit}`);\n      const data = await response.json();\n\n      // Handle MCP-style response\n      const prescriptions = data.prescriptions || [];\n      if (prescriptions.length > 0) {\n        const prescriptionsList = prescriptions.map(presc => {\n          const date = new Date(presc.prescribed_date);\n          const doctorName = presc.doctor_name ? `by Dr. ${presc.doctor_name}` : 'by Unknown Doctor';\n          return `ðŸ“œ ${presc.medicine_name} (${presc.dosage}) - ${presc.duration}\\n   Prescribed on ${date.toLocaleDateString()} ${doctorName}\\n   Status: ${presc.status}`;\n        }).join('\\n\\n');\n        let displayText;\n        if (count) {\n          displayText = `Your last ${prescriptions.length} prescription${prescriptions.length !== 1 ? 's' : ''}:\\n\\n${prescriptionsList}`;\n        } else if (timeframe === \"all\") {\n          displayText = `All your prescriptions (${prescriptions.length} total):\\n\\n${prescriptionsList}`;\n        } else {\n          displayText = `Your recent prescriptions (last ${prescriptions.length}):\\n\\n${prescriptionsList}`;\n        }\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: displayText\n        }]);\n      } else {\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: data.message || \"No prescription history found.\"\n        }]);\n      }\n    } catch (error) {\n      setChat(prev => [...prev, {\n        sender: \"bot\",\n        text: \"Error fetching prescription history.\"\n      }]);\n    }\n  };\n\n  // Helper function to handle appointment booking\n  const handleAppointmentBooking = async (specialist = null) => {\n    try {\n      setChat(prev => [...prev, {\n        sender: \"bot\",\n        text: specialist ? `Looking for available ${specialist} doctors...` : \"Looking for available doctors...\"\n      }]);\n      const url = specialist ? `http://localhost:3001/api/doctors/available-slots?specialist=${specialist}` : `http://localhost:3001/api/doctors/available-slots`;\n      const response = await fetch(url);\n      const data = await response.json();\n      if (data.doctors && data.doctors.length > 0) {\n        setDoctorListCache(data.doctors);\n        const doctorsList = data.doctors.map(doc => {\n          let availabilityText = \"\";\n          if (doc.slots && Object.keys(doc.slots).length > 0) {\n            const availableDays = Object.keys(doc.slots).filter(day => doc.slots[day] && doc.slots[day].length > 0).map(day => {\n              const slots = doc.slots[day];\n              const timeRange = `${slots[0].time} - ${slots[slots.length - 1].time}`;\n              return `${day}: ${timeRange}`;\n            });\n            availabilityText = availableDays.length > 0 ? `\\n   Available: ${availableDays.join(\", \")}` : \"\\n   No availability set\";\n          } else {\n            availabilityText = \"\\n   No availability set\";\n          }\n          return `Dr. ${doc.full_name} (ID: ${doc.id}) - ${doc.specialization}${availabilityText}`;\n        }).join(\"\\n\\n\");\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: `Available ${specialist || ''}doctors:\\n\\n${doctorsList}\\n\\nTo book, you can either:\\n1. Type just the doctor ID number (e.g., \"1\" for Dr. Smith)\\n2. Type: \"book my appointment for doctor id [ID] on YYYY-MM-DD, HH:MM AM/PM\"\\n\\nExample: \"book my appointment for doctor id 1 on 2025-07-15, 10:00 AM\"`\n        }]);\n      } else {\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: `Sorry, no ${specialist || ''}doctors are available at the moment.`\n        }]);\n      }\n    } catch (error) {\n      setChat(prev => [...prev, {\n        sender: \"bot\",\n        text: \"Error fetching doctors. Please try again later.\"\n      }]);\n    }\n  };\n\n  // Helper function to handle direct booking\n  const handleDirectBooking = async bookingMatch => {\n    const doctorId = parseInt(bookingMatch[1], 10);\n    const dateStr = bookingMatch[2];\n    const slot = bookingMatch[3].toUpperCase();\n\n    // If no doctor cache, fetch the doctor info directly\n    let doctor = doctorListCache === null || doctorListCache === void 0 ? void 0 : doctorListCache.find(d => d.id === doctorId);\n    if (!doctor) {\n      try {\n        const response = await fetch(`http://localhost:3001/api/doctors/available-slots`);\n        const data = await response.json();\n        if (data.doctors && data.doctors.length > 0) {\n          setDoctorListCache(data.doctors);\n          doctor = data.doctors.find(d => d.id === doctorId);\n        }\n      } catch (error) {\n        console.error(\"Error fetching doctor info:\", error);\n      }\n    }\n    if (!doctor) {\n      setChat(prev => [...prev, {\n        sender: \"bot\",\n        text: \"Invalid doctor selection. Please try again or use the Book Appointment button to see available doctors.\"\n      }]);\n      return;\n    }\n    const dayOfWeek = new Date(dateStr).toLocaleString(\"en-US\", {\n      weekday: \"long\"\n    });\n\n    // Better slot normalization to handle leading zeros and missing minutes\n    const normalizeSlot = timeStr => {\n      // First normalize the format to always include minutes\n      const timeRegex = /^(\\d{1,2})(?::(\\d{2}))?\\s*(AM|PM)$/i;\n      const match = timeStr.match(timeRegex);\n      if (match) {\n        const hour = match[1];\n        const minute = match[2] || '00'; // Default to '00' if no minutes\n        const ampm = match[3].toUpperCase();\n        return `${hour}:${minute}${ampm}`;\n      }\n\n      // Fallback to original normalization\n      return timeStr.replace(/\\s+/g, '').toUpperCase().replace(/^0+(\\d)/, '$1');\n    };\n    const normalizedSlot = normalizeSlot(slot);\n    const availableSlots = (doctor.slots[dayOfWeek] || []).map(s => normalizeSlot(s.time));\n\n    // Check slot availability\n    console.log(\"=== SLOT NORMALIZATION DEBUG ===\");\n    console.log(\"User input slot:\", slot);\n    console.log(\"Normalized user slot:\", normalizedSlot);\n    console.log(\"Available slots raw:\", doctor.slots[dayOfWeek]);\n    console.log(\"Available slots normalized:\", availableSlots);\n    console.log(\"Match found:\", availableSlots.includes(normalizedSlot));\n    if (!availableSlots.includes(normalizedSlot)) {\n      const availableDaysText = Object.keys(doctor.slots).filter(day => doctor.slots[day] && doctor.slots[day].length > 0).map(day => `${day}: ${doctor.slots[day].map(s => s.time).join(', ')}`).join('\\n   ');\n      setChat(prev => [...prev, {\n        sender: \"bot\",\n        text: `Selected slot (${slot}) is not available on ${dayOfWeek}.\\n\\nDr. ${doctor.full_name} is available:\\n   ${availableDaysText || 'No availability set'}\\n\\nPlease choose an available slot.`\n      }]);\n      return;\n    }\n\n    // Check if slot is already booked\n    try {\n      const appointmentsRes = await fetch(`http://localhost:3001/api/doctors/appointments/${doctor.id}?date=${dateStr}`);\n      const appointmentsData = await appointmentsRes.json();\n      const bookedSlots = new Set();\n      if (appointmentsData.appointments) {\n        appointmentsData.appointments.forEach(appt => {\n          const apptDate = new Date(appt.appointment_time);\n          const hour = apptDate.getHours();\n          let displayHour = hour % 12 === 0 ? 12 : hour % 12;\n          let ampm = hour < 12 ? \"AM\" : \"PM\";\n          let slotStr = normalizeSlot(`${displayHour}:00 ${ampm}`);\n          bookedSlots.add(slotStr);\n        });\n      }\n      if (bookedSlots.has(normalizedSlot)) {\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: \"This slot is already booked. Please choose another slot.\"\n        }]);\n        return;\n      }\n\n      // Parse and book appointment with improved time parsing\n      const parseTimeSlot = timeSlot => {\n        // Handle formats: \"5PM\", \"5 PM\", \"5:00PM\", \"5:00 PM\", \"05:00 PM\", etc.\n        const timeRegex = /^(\\d{1,2})(?::(\\d{2}))?\\s*(AM|PM)$/i;\n        const match = timeSlot.match(timeRegex);\n        if (!match) {\n          throw new Error(`Invalid time format: ${timeSlot}`);\n        }\n        let hour = parseInt(match[1], 10);\n        const minute = match[2] ? parseInt(match[2], 10) : 0; // Default to 0 if no minutes provided\n        const ampm = match[3].toUpperCase();\n        if (ampm === \"PM\" && hour !== 12) hour += 12;\n        if (ampm === \"AM\" && hour === 12) hour = 0;\n        return {\n          hour,\n          minute\n        };\n      };\n      let appointment_time;\n      try {\n        const {\n          hour,\n          minute\n        } = parseTimeSlot(slot);\n        appointment_time = `${dateStr} ${hour.toString().padStart(2, \"0\")}:${minute.toString().padStart(2, \"0\")}:00`;\n        console.log(\"Parsed time:\", {\n          originalSlot: slot,\n          hour,\n          minute,\n          appointment_time\n        });\n      } catch (parseError) {\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: `Invalid time format. Please use format like \"5PM\", \"5:00PM\", or \"5:00 PM\"`\n        }]);\n        return;\n      }\n      const patient_id = (user === null || user === void 0 ? void 0 : user.id) || 1;\n      const bookRes = await fetch(\"http://localhost:3001/api/doctors/book-appointment\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          context: {\n            patient_id,\n            doctor_id: doctorId,\n            appointment_time\n          }\n        })\n      });\n      const bookData = await bookRes.json();\n      if (bookRes.ok && bookData.context && bookData.context.status === \"booked\") {\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: `âœ… Appointment booked with Dr. ${doctor.full_name} on ${dateStr} at ${slot}.`\n        }]);\n      } else {\n        setChat(prev => [...prev, {\n          sender: \"bot\",\n          text: bookData.message || bookData.error || \"Failed to book appointment.\"\n        }]);\n      }\n    } catch (error) {\n      console.error(\"Error in handleDirectBooking:\", error);\n      setChat(prev => [...prev, {\n        sender: \"bot\",\n        text: \"Error processing booking. Please try again.\"\n      }]);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(ChatWindow, {\n    messages: chat,\n    buttons: buttons,\n    onUserInput: handleUserInput,\n    onFileUpload: handleFileUpload,\n    isProcessing: isAnalyzing\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1340,\n    columnNumber: 5\n  }, this);\n};\n_s(SmartTriage, \"snnFACCVbcTbvRBxyIxUJ/lRs6o=\");\n_c = SmartTriage;\nexport default SmartTriage;\nvar _c;\n$RefreshReg$(_c, \"SmartTriage\");","map":{"version":3,"names":["React","useState","ChatWindow","jsxDEV","_jsxDEV","SmartTriage","role","user","onNavigate","_s","chat","setChat","sender","text","isAnalyzing","setIsAnalyzing","awaitingSymptoms","setAwaitingSymptoms","awaitingBooking","setAwaitingBooking","suggestedSpecialist","setSuggestedSpecialist","doctorListCache","setDoctorListCache","awaitingMedicineInput","setAwaitingMedicineInput","awaitingPatientId","setAwaitingPatientId","awaitingPrescriptionChoice","setAwaitingPrescriptionChoice","commonButtons","label","type","patientButtons","doctorButtons","buttons","geminiParseInput","input","context","response","fetch","method","headers","body","JSON","stringify","userInput","ok","data","json","cleanResponse","replace","trim","parse","parseError","console","log","error","detectIntent","toLowerCase","geminiResult","intent","count","timeframe","doctor_id","specialist","date","time","action","patient_identifier","patient_type","medicines","symptoms","target","test","prescriptionPatterns","some","pattern","analyzeSymptoms","prev","isLoading","Error","analysisText","specialistMatch","match","filter","msg","explainPrescription","prescriptionText","handleFileUpload","file","allowedTypes","includes","size","name","formData","FormData","append","handleUserInput","fromUser","showFileUpload","patient_id","id","appointments","length","appointmentsList","map","appt","Date","appointment_time","toLocaleDateString","toLocaleTimeString","doctor_name","join","message","handlePrescriptionHistoryWithParams","handleAppointmentBooking","patient_name","choice","limit","prescriptions","prescriptionsList","presc","prescribed_date","doctorName","medicine_name","dosage","duration","status","displayText","lines","split","patientUsernameLine","find","line","patientUsername","medicineLines","startsWith","potentialMedicineLines","trimmed","concat","parts","substring","s","push","instructions","lookupResponse","lookupData","patientId","patient","patientName","full_name","successCount","failCount","results","medicine","summary","patientIdOrUsername","isNumeric","isNaN","parseInt","lookupError","fallbackError","patientInput","parsed","patientResponse","patientData","doctorId","doctor","d","availabilityText","slots","Object","keys","availableDays","day","timeSlots","specialization","bookingRegex","bookingMatch","handleDirectBooking","answer","symptomKeywords","lower","kw","prescriptionKeywords","handleMedicineAdditionFromGemini","handlePatientLookupFromGemini","toString","intentResult","url","doctors","doctorsList","doc","timeRange","dateStr","slot","toUpperCase","dayOfWeek","toLocaleString","weekday","normalizeSlot","timeStr","timeRegex","hour","minute","ampm","normalizedSlot","availableSlots","availableDaysText","appointmentsRes","appointmentsData","bookedSlots","Set","forEach","apptDate","getHours","displayHour","slotStr","add","has","parseTimeSlot","timeSlot","padStart","originalSlot","bookRes","bookData","messages","onUserInput","onFileUpload","isProcessing","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/verma/Downloads/Medical Bot/client/src/pages/SmartTriage.js"],"sourcesContent":["import React, { useState } from \"react\";\r\nimport ChatWindow from \"../components/ChatWindow\";\r\n\r\nconst SmartTriage = ({ role = \"patient\", user, onNavigate }) => {\r\n  const [chat, setChat] = useState([\r\n    {\r\n      sender: \"bot\",\r\n      text:\r\n        role === \"doctor\"\r\n          ? \"Welcome Doctor! Use the buttons below to view appointments, check symptoms, or upload a prescription. You can also type natural language requests like 'show patient 1 medicines' or 'check john's active prescriptions'. (ðŸ”¬ Symptom analysis uses RAG-enhanced medical knowledge!)\"\r\n          : \"Welcome to Smart Triage! Use buttons below to start symptom checker, upload prescription, book appointment, view your appointments, or check prescription history. You can also type natural language requests like 'show my recent 3 prescriptions' or 'book appointment with cardiologist'. (ðŸ”¬ Symptom analysis uses RAG-enhanced medical knowledge!)\",\r\n    },\r\n  ]);\r\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\r\n  const [awaitingSymptoms, setAwaitingSymptoms] = useState(false);\r\n  const [awaitingBooking, setAwaitingBooking] = useState(null);\r\n  const [suggestedSpecialist, setSuggestedSpecialist] = useState(null);\r\n  const [doctorListCache, setDoctorListCache] = useState(null);\r\n  const [awaitingMedicineInput, setAwaitingMedicineInput] = useState(false);\r\n  const [awaitingPatientId, setAwaitingPatientId] = useState(false);\r\n  const [awaitingPrescriptionChoice, setAwaitingPrescriptionChoice] = useState(false);\r\n\r\n  // Buttons for both doctor and patient\r\n  const commonButtons = [\r\n    { label: \"ðŸ©º Symptom Checker\", type: \"symptom_checker\" },\r\n    { label: \"ðŸ“„ Upload Prescription\", type: \"upload_prescription\" },\r\n  ];\r\n  const patientButtons = [\r\n    ...commonButtons,\r\n    { label: \"ðŸ“… Book Appointment\", type: \"book_appointment\" },\r\n    { label: \"ðŸ“‹ My Appointments\", type: \"view_my_appointments\" },\r\n    { label: \"ðŸ“œ Prescription History\", type: \"view_prescription_history\" }\r\n  ];\r\n  const doctorButtons = [\r\n    ...commonButtons,\r\n    { label: \"ðŸ“† View Appointments\", type: \"view_appointments\" },\r\n    { label: \"ðŸ’Š Add Medicine for Patient\", type: \"add_medicine\" },\r\n    { label: \"ðŸ“‹ View Patient Medicine History\", type: \"view_patient_medicines\" }\r\n  ];\r\n\r\n  const buttons = role === \"doctor\" ? doctorButtons : patientButtons;\r\n\r\n  // Gemini AI-powered intent detection and entity extraction (NOT RAG - just parsing)\r\n  const geminiParseInput = async (input, context = \"general\") => {\r\n    try {\r\n      const response = await fetch(\"http://localhost:3001/api/ai-response\", {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify({\r\n          type: \"comprehensive-intent-extraction\",\r\n          userInput: input,\r\n          context: context // \"patient\", \"doctor\", or \"general\"\r\n        }),\r\n      });\r\n      \r\n      if (response.ok) {\r\n        const data = await response.json();\r\n        const cleanResponse = data.response.replace(/```json|```/g, '').trim();\r\n        \r\n        try {\r\n          return JSON.parse(cleanResponse);\r\n        } catch (parseError) {\r\n          console.log(\"Failed to parse Gemini response:\", parseError);\r\n          return null;\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.log(\"Gemini parsing failed:\", error);\r\n    }\r\n    return null;\r\n  };\r\n\r\n  // Enhanced intent detection with comprehensive Gemini AI support\r\n  const detectIntent = async (input) => {\r\n    const text = input.toLowerCase();\r\n    \r\n    // Use Gemini for comprehensive intent and entity extraction\r\n    const geminiResult = await geminiParseInput(input, role);\r\n    \r\n    if (geminiResult) {\r\n      // Handle complex extracted intents\r\n      switch (geminiResult.intent) {\r\n        case \"prescription_history\":\r\n          return {\r\n            type: \"view_prescription_history\",\r\n            count: geminiResult.count,\r\n            timeframe: geminiResult.timeframe\r\n          };\r\n        \r\n        case \"book_appointment\":\r\n          return {\r\n            type: \"book_appointment\",\r\n            doctor_id: geminiResult.doctor_id,\r\n            specialist: geminiResult.specialist,\r\n            date: geminiResult.date,\r\n            time: geminiResult.time\r\n          };\r\n        \r\n        case \"patient_lookup\":\r\n          return {\r\n            type: geminiResult.action || \"view_patient_medicines\",\r\n            patient_identifier: geminiResult.patient_identifier,\r\n            patient_type: geminiResult.patient_type\r\n          };\r\n        \r\n        case \"medicine_add\":\r\n          return {\r\n            type: \"add_medicine\",\r\n            patient_identifier: geminiResult.patient_identifier,\r\n            medicines: geminiResult.medicines\r\n          };\r\n        \r\n        case \"symptom_check\":\r\n          return {\r\n            type: \"symptom_checker\",\r\n            symptoms: geminiResult.symptoms\r\n          };\r\n        \r\n        case \"appointment_view\":\r\n          return {\r\n            type: geminiResult.target === \"doctor\" ? \"view_appointments\" : \"view_my_appointments\"\r\n          };\r\n        \r\n        default:\r\n          // Map other intents to existing types\r\n          if (geminiResult.intent) {\r\n            return { type: geminiResult.intent };\r\n          }\r\n      }\r\n    }\r\n    \r\n    // Fallback to quick regex-based detection for common patterns\r\n    if (/book.*appointment/.test(text)) return { type: \"book_appointment\" };\r\n    if (/view.*appointment/.test(text) || /my.*appointment/.test(text)) return { type: \"view_my_appointments\" };\r\n    if (/symptom|check.*symptom/.test(text)) return { type: \"symptom_checker\" };\r\n    if (/upload.*prescription/.test(text)) return { type: \"upload_prescription\" };\r\n    if (/patient.*medicine|medicine.*history|patient.*prescription/.test(text)) return { type: \"view_patient_medicines\" };\r\n    \r\n    // Enhanced prescription history detection with number parsing\r\n    const prescriptionPatterns = [\r\n      /prescription.*list|last.*prescription|prescription.*history/,\r\n      /recent.*prescription|latest.*prescription/,\r\n      /my.*prescription|get.*prescription|fetch.*prescription/,\r\n      /show.*prescription|list.*prescription/\r\n    ];\r\n    \r\n    if (prescriptionPatterns.some(pattern => pattern.test(text))) {\r\n      return { type: \"view_prescription_history\" };\r\n    }\r\n    \r\n    return null;\r\n  };\r\n\r\n  // TRUE RAG: analyzeSymptoms uses medical knowledge database\r\n  const analyzeSymptoms = async (symptoms) => {\r\n    try {\r\n      setIsAnalyzing(true);\r\n      setAwaitingSymptoms(false);\r\n      setChat((prev) => [\r\n        ...prev,\r\n        { sender: \"bot\", text: \"Analyzing your symptoms...\", isLoading: true },\r\n      ]);\r\n      const response = await fetch(\"http://localhost:3001/api/ai-response\", {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify({\r\n          type: \"symptom-specialist\",\r\n          userInput: `Given these symptoms: \"${symptoms}\", what are the possible diseases and which specialist should the patient consult? Respond with:\\nPossible diseases: <list>\\nRecommended specialist: <specialist>\\nIf serious, add: \"Would you like to book an appointment with a <specialist>? (Type yes to proceed)\"`,\r\n        }),\r\n      });\r\n      if (!response.ok) throw new Error(\"Failed to analyze symptoms\");\r\n      const data = await response.json();\r\n      let analysisText = data.response.replace(/\\n/g, \"\\n\");\r\n      const specialistMatch = analysisText.match(/Recommended specialist:\\s*([^\\n]+)/i);\r\n      let specialist = null;\r\n      if (specialistMatch) {\r\n        specialist = specialistMatch[1].trim();\r\n        setSuggestedSpecialist(specialist);\r\n      } else {\r\n        setSuggestedSpecialist(null);\r\n      }\r\n      if (/would you like to book an appointment/i.test(analysisText) && specialist) {\r\n        setAwaitingBooking(specialist);\r\n      } else {\r\n        setAwaitingBooking(null);\r\n      }\r\n      setChat((prev) => [\r\n        ...prev.filter((msg) => !msg.isLoading),\r\n        { sender: \"bot\", text: analysisText },\r\n      ]);\r\n    } catch (error) {\r\n      setChat((prev) => [\r\n        ...prev.filter((msg) => !msg.isLoading),\r\n        { sender: \"bot\", text: \"Sorry, I couldn't analyze your symptoms right now. Please try again later.\" },\r\n      ]);\r\n      console.error(\"Analysis error:\", error);\r\n    } finally {\r\n      setIsAnalyzing(false);\r\n    }\r\n  };\r\n\r\n  // STRUCTURED PROMPTING: prescription explanation (NOT RAG - just AI parsing)\r\n  const explainPrescription = async (prescriptionText) => {\r\n    try {\r\n      setIsAnalyzing(true);\r\n      setChat((prev) => [\r\n        ...prev,\r\n        { sender: \"bot\", text: \"Explaining your prescription...\", isLoading: true },\r\n      ]);\r\n      const response = await fetch(\"http://localhost:3001/api/ai-response\", {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify({\r\n          type: \"prescription\",\r\n          userInput: `Explain this prescription in simple terms for a patient:\\n${prescriptionText}`,\r\n        }),\r\n      });\r\n      if (!response.ok) throw new Error(\"Failed to analyze prescription\");\r\n      const data = await response.json();\r\n      setChat((prev) => [\r\n        ...prev.filter((msg) => !msg.isLoading),\r\n        { sender: \"bot\", text: `ðŸ“ Prescription explained:\\n\\n${data.response.replace(/\\n/g, \"\\n\")}` },\r\n      ]);\r\n    } catch (error) {\r\n      setChat((prev) => [\r\n        ...prev.filter((msg) => !msg.isLoading),\r\n        { sender: \"bot\", text: \"Sorry, I couldn't analyze your prescription right now. Please try again later.\" },\r\n      ]);\r\n      console.error(\"Prescription analysis error:\", error);\r\n    } finally {\r\n      setIsAnalyzing(false);\r\n    }\r\n  };\r\n\r\n  // Handle file upload for prescriptions\r\n  const handleFileUpload = async (file) => {\r\n    if (!file) return;\r\n\r\n    // Validate file type\r\n    const allowedTypes = [\r\n      'image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/bmp',\r\n      'application/pdf', 'text/plain'\r\n    ];\r\n    \r\n    if (!allowedTypes.includes(file.type)) {\r\n      setChat((prev) => [\r\n        ...prev,\r\n        { sender: \"bot\", text: \"âŒ Unsupported file type. Please upload an image (JPG, PNG), PDF, or text file.\" },\r\n      ]);\r\n      return;\r\n    }\r\n\r\n    // Check file size (max 10MB)\r\n    if (file.size > 10 * 1024 * 1024) {\r\n      setChat((prev) => [\r\n        ...prev,\r\n        { sender: \"bot\", text: \"âŒ File too large. Please upload a file smaller than 10MB.\" },\r\n      ]);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setIsAnalyzing(true);\r\n      setChat((prev) => [\r\n        ...prev,\r\n        { sender: \"user\", text: `ðŸ“Ž Uploaded: ${file.name}` },\r\n        { sender: \"bot\", text: \"ðŸ“‹ Analyzing your medical document...\", isLoading: true },\r\n      ]);\r\n\r\n      const formData = new FormData();\r\n      formData.append('file', file);\r\n      formData.append('type', 'prescription');\r\n\r\n      const response = await fetch(\"http://localhost:3001/api/ai-response\", {\r\n        method: \"POST\",\r\n        body: formData,\r\n      });\r\n\r\n      if (!response.ok) throw new Error(\"Failed to analyze document\");\r\n      \r\n      const data = await response.json();\r\n      \r\n      setChat((prev) => [\r\n        ...prev.filter((msg) => !msg.isLoading),\r\n        { \r\n          sender: \"bot\", \r\n          text: `ðŸ“‹ **Medical Document Analysis:**\\n\\n${data.response}`\r\n        },\r\n      ]);\r\n    } catch (error) {\r\n      setChat((prev) => [\r\n        ...prev.filter((msg) => !msg.isLoading),\r\n        { sender: \"bot\", text: \"âŒ Failed to analyze the document. Please try again or type the prescription text manually.\" },\r\n      ]);\r\n      console.error(\"File upload error:\", error);\r\n    } finally {\r\n      setIsAnalyzing(false);\r\n    }\r\n  };\r\n\r\n  // Main user input handler\r\n  const handleUserInput = async (input, fromUser = true) => {\r\n    if (fromUser) {\r\n      if (typeof input === \"string\") {\r\n        setChat((prev) => [...prev, { sender: \"user\", text: input }]);\r\n      } else if (input && input.label) {\r\n        setChat((prev) => [...prev, { sender: \"user\", text: input.label }]);\r\n      }\r\n    }\r\n\r\n    // Handle button actions\r\n    if (input && input.type) {\r\n      // Reset states when new button is clicked\r\n      setAwaitingSymptoms(false);\r\n      setAwaitingMedicineInput(false);\r\n      setAwaitingPatientId(false);\r\n      setAwaitingPrescriptionChoice(false);\r\n      \r\n      switch (input.type) {\r\n        case \"symptom_checker\":\r\n          setChat((prev) => [\r\n            ...prev,\r\n            { sender: \"bot\", text: \"Please describe your symptoms in detail.\" },\r\n          ]);\r\n          setAwaitingSymptoms(true);\r\n          return;\r\n\r\n        case \"upload_prescription\":\r\n          setChat((prev) => [\r\n            ...prev,\r\n            { \r\n              sender: \"bot\", \r\n              text: \"Please upload your prescription or medical document. I can analyze:\\n\\nðŸ“‹ Images (JPG, PNG, etc.)\\nðŸ“„ PDF documents\\nðŸ“ Text files\\n\\nOr you can type the prescription text directly.\", \r\n              showFileUpload: true \r\n            },\r\n          ]);\r\n          return;\r\n\r\n        case \"view_my_appointments\":\r\n          try {\r\n            const patient_id = user?.id || 1;\r\n            const response = await fetch(`http://localhost:3001/api/patients/appointments/${patient_id}`);\r\n            const data = await response.json();\r\n            \r\n            // Handle MCP-style response\r\n            const appointments = data.appointments || [];\r\n            if (appointments.length > 0) {\r\n              const appointmentsList = appointments.map(appt => {\r\n                const date = new Date(appt.appointment_time);\r\n                return `ðŸ“… ${date.toLocaleDateString()} at ${date.toLocaleTimeString()} with Dr. ${appt.doctor_name}`;\r\n              }).join('\\n');\r\n              \r\n              setChat((prev) => [\r\n                ...prev,\r\n                { sender: \"bot\", text: `Your upcoming appointments:\\n\\n${appointmentsList}` },\r\n              ]);\r\n            } else {\r\n              setChat((prev) => [\r\n                ...prev,\r\n                { sender: \"bot\", text: data.message || \"You have no upcoming appointments.\" },\r\n              ]);\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error fetching appointments:\", error);\r\n            setChat((prev) => [\r\n              ...prev,\r\n              { sender: \"bot\", text: \"Error fetching appointments. Please try again later.\" },\r\n            ]);\r\n          }\r\n          return;\r\n\r\n        case \"view_prescription_history\":\r\n          // Check if we have enhanced parameters from Gemini\r\n          if (input.count || input.timeframe) {\r\n            await handlePrescriptionHistoryWithParams(input.count, input.timeframe);\r\n          } else {\r\n            // Default behavior - ask user for choice\r\n            setChat((prev) => [\r\n              ...prev,\r\n              { sender: \"user\", text: \"You chose Prescription History\" },\r\n              { sender: \"bot\", text: \"Would you like to see:\\n\\nðŸ“‹ **All** prescriptions\\nðŸ•’ **Recent** prescriptions (last 10)\\n\\nPlease type 'all' or 'recent':\" },\r\n            ]);\r\n            setAwaitingPrescriptionChoice(true);\r\n          }\r\n          return;\r\n\r\n        case \"book_appointment\":\r\n          await handleAppointmentBooking(input.specialist);\r\n          return;\r\n\r\n        case \"view_appointments\":\r\n          // Doctor view appointments - MCP style\r\n          try {\r\n            const doctor_id = user?.id || 1;\r\n            const response = await fetch(`http://localhost:3001/api/doctors/appointments/${doctor_id}`);\r\n            const data = await response.json();\r\n            \r\n            // Handle MCP-style response\r\n            const appointments = data.appointments || [];\r\n            if (appointments.length > 0) {\r\n              const appointmentsList = appointments.map(appt => {\r\n                const date = new Date(appt.appointment_time);\r\n                return `ðŸ“… ${date.toLocaleDateString()} at ${date.toLocaleTimeString()} with ${appt.patient_name}`;\r\n              }).join('\\n');\r\n              \r\n              setChat((prev) => [\r\n                ...prev,\r\n                { sender: \"bot\", text: `Your appointments:\\n\\n${appointmentsList}` },\r\n              ]);\r\n            } else {\r\n              setChat((prev) => [\r\n                ...prev,\r\n                { sender: \"bot\", text: data.message || \"You have no scheduled appointments.\" },\r\n              ]);\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error fetching appointments:\", error);\r\n            setChat((prev) => [\r\n              ...prev,\r\n              { sender: \"bot\", text: \"Error fetching appointments. Please try again later.\" },\r\n            ]);\r\n          }\r\n          return;\r\n\r\n        case \"add_medicine\":\r\n          setChat((prev) => [\r\n            ...prev,\r\n            { sender: \"bot\", text: \"Please enter medicines in this format:\\nPatient Username: [username]\\nMedicines:\\n- [Medicine Name], [Dosage], [Duration], [Instructions]\\n- [Medicine Name], [Dosage], [Duration], [Instructions]\\n\\nExample (with dashes):\\nPatient Username: mrigankshekharverma\\nMedicines:\\n- Paracetamol, 500mg, 5 days, Take twice daily after meals\\n- Vitamin D3, 1000 IU, 30 days, Take once daily with breakfast\\n\\nExample (without dashes also works):\\nPatient Username: mrigankshekharverma\\nMedicines:\\nParacetamol, 500mg, 5 days, Take twice daily after meals\\nVitamin D3, 1000 IU, 30 days, Take once daily with breakfast\" }\r\n          ]);\r\n          setAwaitingMedicineInput(true);\r\n          return;\r\n\r\n        case \"view_patient_medicines\":\r\n          setChat((prev) => [\r\n            ...prev,\r\n            { sender: \"bot\", text: \"Please enter the patient's username or patient ID to view their medicine history:\" }\r\n          ]);\r\n          setAwaitingPatientId(true);\r\n          return;\r\n\r\n      }\r\n    }\r\n\r\n    // Handle prescription choice (all or recent)\r\n    if (awaitingPrescriptionChoice && typeof input === \"string\") {\r\n      setAwaitingPrescriptionChoice(false);\r\n      const choice = input.toLowerCase().trim();\r\n      \r\n      if (choice === \"all\" || choice === \"recent\") {\r\n        try {\r\n          const patient_id = user?.id || 1;\r\n          const limit = choice === \"all\" ? 1000 : 10;\r\n          const response = await fetch(`http://localhost:3001/api/patients/${patient_id}/prescription-history?limit=${limit}`);\r\n          const data = await response.json();\r\n          \r\n          // Handle MCP-style response\r\n          const prescriptions = data.prescriptions || [];\r\n          if (prescriptions.length > 0) {\r\n            const prescriptionsList = prescriptions.map(presc => {\r\n              const date = new Date(presc.prescribed_date);\r\n              const doctorName = presc.doctor_name ? `by Dr. ${presc.doctor_name}` : 'by Unknown Doctor';\r\n              return `ðŸ“œ ${presc.medicine_name} (${presc.dosage}) - ${presc.duration}\\n   Prescribed on ${date.toLocaleDateString()} ${doctorName}\\n   Status: ${presc.status}`;\r\n            }).join('\\n\\n');\r\n            \r\n            const displayText = choice === \"all\" \r\n              ? `All your prescriptions (${prescriptions.length} total):\\n\\n${prescriptionsList}`\r\n              : `Your recent prescriptions (last ${prescriptions.length}):\\n\\n${prescriptionsList}`;\r\n            \r\n            setChat((prev) => [\r\n              ...prev,\r\n              { sender: \"bot\", text: displayText },\r\n            ]);\r\n          } else {\r\n            setChat((prev) => [\r\n              ...prev,\r\n              { sender: \"bot\", text: data.message || \"No prescription history found.\" },\r\n            ]);\r\n          }\r\n        } catch (error) {\r\n          setChat((prev) => [\r\n            ...prev,\r\n            { sender: \"bot\", text: \"Error fetching prescription history.\" },\r\n          ]);\r\n        }\r\n      } else {\r\n        setChat((prev) => [\r\n          ...prev,\r\n          { sender: \"bot\", text: \"Please type 'all' or 'recent' to choose what prescriptions to view.\" },\r\n        ]);\r\n        setAwaitingPrescriptionChoice(true);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle medicine input for doctors - MCP style\r\n    if (awaitingMedicineInput && typeof input === \"string\") {\r\n      setAwaitingMedicineInput(false);\r\n      \r\n      try {\r\n        // Parse the new format\r\n        const lines = input.trim().split('\\n');\r\n        const patientUsernameLine = lines.find(line => line.toLowerCase().includes('patient username'));\r\n        \r\n        if (!patientUsernameLine) {\r\n          setChat((prev) => [...prev, { sender: \"bot\", text: \"Please include 'Patient Username: [username]' in your input.\" }]);\r\n          return;\r\n        }\r\n        \r\n        const patientUsername = patientUsernameLine.split(':')[1].trim();\r\n        if (!patientUsername) {\r\n          setChat((prev) => [...prev, { sender: \"bot\", text: \"Please provide a valid patient username.\" }]);\r\n          return;\r\n        }\r\n        \r\n        // Extract medicine lines (lines starting with - OR valid medicine format)\r\n        let medicineLines = lines.filter(line => line.trim().startsWith('-'));\r\n        \r\n        // Also check for medicine-like lines without dashes\r\n        const potentialMedicineLines = lines.filter(line => {\r\n          const trimmed = line.trim();\r\n          return trimmed.length > 0 && \r\n                 !trimmed.toLowerCase().includes('patient username') && \r\n                 !trimmed.toLowerCase().includes('medicines:') &&\r\n                 !trimmed.startsWith('-') && // Not already processed\r\n                 trimmed.includes(',') &&\r\n                 trimmed.split(',').length >= 3; // At least name, dosage, duration\r\n        });\r\n        \r\n        if (potentialMedicineLines.length > 0) {\r\n          // Add non-dashed medicine lines, prefixed with dashes for processing\r\n          medicineLines = medicineLines.concat(potentialMedicineLines.map(line => `- ${line.trim()}`));\r\n        }\r\n        \r\n        if (medicineLines.length === 0) {\r\n          setChat((prev) => [...prev, { sender: \"bot\", text: \"Please include at least one medicine in the correct format.\\n\\nExample:\\n- Paracetamol, 500mg, 5 days, Take twice daily after meals\\n\\nOr without dashes:\\nParacetamol, 500mg, 5 days, Take twice daily after meals\" }]);\r\n          return;\r\n        }\r\n        \r\n        // Parse each medicine BEFORE patient lookup\r\n        const medicines = [];\r\n        for (const line of medicineLines) {\r\n          const parts = line.substring(1).split(',').map(s => s.trim()); // Remove '-' and split\r\n          if (parts.length >= 3) {\r\n            medicines.push({\r\n              name: parts[0],\r\n              dosage: parts[1],\r\n              duration: parts[2],\r\n              instructions: parts[3] || \"As prescribed by doctor\"\r\n            });\r\n          }\r\n        }\r\n        \r\n        if (medicines.length === 0) {\r\n          setChat((prev) => [...prev, { sender: \"bot\", text: \"Please use correct format: - Medicine Name, Dosage, Duration, Instructions\" }]);\r\n          return;\r\n        }\r\n        \r\n        // NOW do patient lookup after validating format\r\n        const lookupResponse = await fetch(`http://localhost:3001/api/patients/lookup/${patientUsername}`);\r\n        const lookupData = await lookupResponse.json();\r\n        \r\n        if (!lookupResponse.ok || lookupData.context.status !== \"found\") {\r\n          setChat((prev) => [...prev, { sender: \"bot\", text: `Patient not found with username: ${patientUsername}. Please check the username and try again.` }]);\r\n          return;\r\n        }\r\n        \r\n        const patientId = lookupData.patient.id;\r\n        const patientName = lookupData.patient.full_name;\r\n        \r\n        // Add each medicine\r\n        let successCount = 0;\r\n        let failCount = 0;\r\n        const results = [];\r\n        \r\n        for (const medicine of medicines) {\r\n          try {\r\n            const response = await fetch(\"http://localhost:3001/api/prescriptions/add\", {\r\n              method: \"POST\",\r\n              headers: { \"Content-Type\": \"application/json\" },\r\n              body: JSON.stringify({\r\n                context: {\r\n                  patient_id: patientId,\r\n                  doctor_id: user?.id || 1,\r\n                  medicine_name: medicine.name,\r\n                  dosage: medicine.dosage,\r\n                  duration: medicine.duration,\r\n                  instructions: medicine.instructions\r\n                }\r\n              })\r\n            });\r\n            const data = await response.json();\r\n            \r\n            if (data.context && data.context.status === \"prescribed\") {\r\n              successCount++;\r\n              results.push(`âœ… ${medicine.name} - Added successfully`);\r\n            } else {\r\n              failCount++;\r\n              results.push(`âŒ ${medicine.name} - ${data.error || \"Failed to add\"}`);\r\n            }\r\n          } catch (error) {\r\n            failCount++;\r\n            results.push(`âŒ ${medicine.name} - Error adding medicine`);\r\n          }\r\n        }\r\n        \r\n        const summary = `Added ${successCount} medicine(s) for ${patientName} (${patientUsername})${failCount > 0 ? `, ${failCount} failed` : ''}:\\n\\n${results.join('\\n')}`;\r\n        setChat((prev) => [...prev, { sender: \"bot\", text: summary }]);\r\n        \r\n      } catch (error) {\r\n        // Fallback to old format for backward compatibility\r\n        const [patientIdOrUsername, name, dosage, duration] = input.split(\",\").map(s => s.trim());\r\n        \r\n        // Check if it's a number (old format) or username (new format)\r\n        const isNumeric = !isNaN(patientIdOrUsername);\r\n        let patientId;\r\n        \r\n        if (isNumeric) {\r\n          // Old format with patient ID\r\n          patientId = parseInt(patientIdOrUsername);\r\n        } else {\r\n          // Try to lookup username\r\n          try {\r\n            const lookupResponse = await fetch(`http://localhost:3001/api/patients/lookup/${patientIdOrUsername}`);\r\n            const lookupData = await lookupResponse.json();\r\n            \r\n            if (!lookupResponse.ok || lookupData.context.status !== \"found\") {\r\n              setChat((prev) => [...prev, { sender: \"bot\", text: `Patient not found: ${patientIdOrUsername}. Please check the format.` }]);\r\n              return;\r\n            }\r\n            patientId = lookupData.patient.id;\r\n          } catch (lookupError) {\r\n            setChat((prev) => [...prev, { sender: \"bot\", text: \"Failed to lookup patient. Please check the format.\" }]);\r\n            return;\r\n          }\r\n        }\r\n        \r\n        try {\r\n          const response = await fetch(\"http://localhost:3001/api/prescriptions/add\", {\r\n            method: \"POST\",\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({\r\n              context: {\r\n                patient_id: patientId,\r\n                doctor_id: user?.id || 1,\r\n                medicine_name: name,\r\n                dosage: dosage,\r\n                duration: duration,\r\n                instructions: \"As prescribed by doctor\"\r\n              }\r\n            })\r\n          });\r\n          const data = await response.json();\r\n          \r\n          if (data.context && data.context.status === \"prescribed\") {\r\n            setChat((prev) => [...prev, { sender: \"bot\", text: data.message || \"Medicine added for patient.\" }]);\r\n          } else {\r\n            setChat((prev) => [...prev, { sender: \"bot\", text: data.error || \"Failed to add medicine.\" }]);\r\n          }\r\n        } catch (fallbackError) {\r\n          setChat((prev) => [...prev, { sender: \"bot\", text: \"Failed to add medicine. Please check the format.\" }]);\r\n        }\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle patient username input for viewing medicine history with enhanced NLP\r\n    if (awaitingPatientId && typeof input === \"string\") {\r\n      setAwaitingPatientId(false);\r\n      let patientInput = input.trim();\r\n      \r\n      // Try to extract patient identifier using Gemini for natural language\r\n      if (!/^\\d+$/.test(patientInput) && !patientInput.includes('@') && patientInput.length > 3) {\r\n        try {\r\n          const response = await fetch(\"http://localhost:3001/api/ai-response\", {\r\n            method: \"POST\",\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({\r\n              type: \"patient-extraction\",\r\n              userInput: `Extract patient identifier from: \"${input}\"\\n\\nRespond with ONLY a JSON object:\\n{\\n  \"patient_identifier\": \"username_or_id\",\\n  \"type\": \"username|id|unknown\"\\n}\\n\\nExamples:\\n- \"patient john doe\" -> {\"patient_identifier\": \"johndoe\", \"type\": \"username\"}\\n- \"user mrigank\" -> {\"patient_identifier\": \"mrigank\", \"type\": \"username\"}\\n- \"patient id 5\" -> {\"patient_identifier\": \"5\", \"type\": \"id\"}\\n- \"123\" -> {\"patient_identifier\": \"123\", \"type\": \"id\"}`\r\n            }),\r\n          });\r\n          \r\n          if (response.ok) {\r\n            const data = await response.json();\r\n            const cleanResponse = data.response.replace(/```json|```/g, '').trim();\r\n            \r\n            try {\r\n              const parsed = JSON.parse(cleanResponse);\r\n              if (parsed.patient_identifier && parsed.type !== \"unknown\") {\r\n                patientInput = parsed.patient_identifier;\r\n              }\r\n            } catch (parseError) {\r\n              console.log(\"Failed to parse patient extraction:\", parseError);\r\n            }\r\n          }\r\n        } catch (error) {\r\n          console.log(\"Gemini patient extraction failed:\", error);\r\n        }\r\n      }\r\n      \r\n      if (!patientInput) {\r\n        setChat((prev) => [...prev, { sender: \"bot\", text: \"Please enter a valid patient username or ID.\" }]);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        let patientId, patientName;\r\n        \r\n        // Check if input is a number (patient ID) or username\r\n        if (/^\\d+$/.test(patientInput)) {\r\n          // Input is a number, treat as patient ID\r\n          patientId = parseInt(patientInput, 10);\r\n          \r\n          // Fetch patient details by ID\r\n          const patientResponse = await fetch(`http://localhost:3001/api/patients/${patientId}`);\r\n          const patientData = await patientResponse.json();\r\n          \r\n          if (!patientResponse.ok || !patientData.patient) {\r\n            setChat((prev) => [...prev, { sender: \"bot\", text: `Patient not found with ID: ${patientId}. Please check the ID and try again.` }]);\r\n            return;\r\n          }\r\n          \r\n          patientName = patientData.patient.full_name;\r\n        } else {\r\n          // Input is a username, lookup patient ID from username\r\n          const lookupResponse = await fetch(`http://localhost:3001/api/patients/lookup/${patientInput}`);\r\n          const lookupData = await lookupResponse.json();\r\n          \r\n          if (!lookupResponse.ok || lookupData.context.status !== \"found\") {\r\n            setChat((prev) => [...prev, { sender: \"bot\", text: `Patient not found with username: ${patientInput}. Please check the username and try again.` }]);\r\n            return;\r\n          }\r\n          \r\n          patientId = lookupData.patient.id;\r\n          patientName = lookupData.patient.full_name;\r\n        }\r\n        \r\n        // Now fetch prescription history\r\n        const response = await fetch(`http://localhost:3001/api/patients/${patientId}/prescription-history`);\r\n        const data = await response.json();\r\n        \r\n        // Handle MCP-style response\r\n        const prescriptions = data.prescriptions || [];\r\n        if (prescriptions.length > 0) {\r\n          const prescriptionsList = prescriptions.map(presc => {\r\n            const date = new Date(presc.prescribed_date);\r\n            const doctorName = presc.doctor_name ? `by Dr. ${presc.doctor_name}` : 'by Unknown Doctor';\r\n            return `ðŸ“œ ${presc.medicine_name} (${presc.dosage}) - ${presc.duration}\\n   Prescribed on ${date.toLocaleDateString()} ${doctorName}\\n   Status: ${presc.status}\\n   Instructions: ${presc.instructions || 'None'}`;\r\n          }).join('\\n\\n');\r\n          \r\n          setChat((prev) => [\r\n            ...prev,\r\n            { sender: \"bot\", text: `Medicine history for ${patientName} (${/^\\d+$/.test(patientInput) ? `ID: ${patientInput}` : patientInput}):\\n\\n${prescriptionsList}` },\r\n          ]);\r\n        } else {\r\n          setChat((prev) => [\r\n            ...prev,\r\n            { sender: \"bot\", text: data.message || `No prescription history found for ${patientName} (${/^\\d+$/.test(patientInput) ? `ID: ${patientInput}` : patientInput}).` },\r\n          ]);\r\n        }\r\n      } catch (error) {\r\n        setChat((prev) => [\r\n          ...prev,\r\n          { sender: \"bot\", text: `Error fetching medicine history for patient: ${patientInput}.` },\r\n        ]);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle simple number input for doctor selection (when doctor list is shown)\r\n    if (typeof input === \"string\" && /^\\d+$/.test(input.trim()) && doctorListCache) {\r\n      const doctorId = parseInt(input.trim(), 10);\r\n      const doctor = doctorListCache.find(d => d.id === doctorId);\r\n      \r\n      if (doctor) {\r\n        // Show doctor details and ask for appointment details\r\n        let availabilityText = \"\";\r\n        if (doctor.slots && Object.keys(doctor.slots).length > 0) {\r\n          const availableDays = Object.keys(doctor.slots)\r\n            .filter(day => doctor.slots[day] && doctor.slots[day].length > 0)\r\n            .map(day => {\r\n              const slots = doctor.slots[day];\r\n              const timeSlots = slots.map(s => s.time).join(\", \");\r\n              return `${day}: ${timeSlots}`;\r\n            });\r\n          \r\n          availabilityText = availableDays.length > 0 \r\n            ? `\\n\\nAvailable slots:\\n${availableDays.join(\"\\n\")}`\r\n            : \"\\nNo availability set\";\r\n        }\r\n        \r\n        setChat((prev) => [\r\n          ...prev,\r\n          { \r\n            sender: \"bot\", \r\n            text: `You selected Dr. ${doctor.full_name} (${doctor.specialization})${availabilityText}\\n\\nTo book an appointment, type:\\n\"book my appointment for doctor id ${doctor.id} on YYYY-MM-DD, HH:MM AM/PM\"\\n\\nExample: \"book my appointment for doctor id ${doctor.id} on 2025-07-15, 10:00 AM\"` \r\n          }\r\n        ]);\r\n        return;\r\n      } else {\r\n        setChat((prev) => [\r\n          ...prev,\r\n          { sender: \"bot\", text: `Doctor with ID ${doctorId} not found in the current list. Please choose from the available doctors above.` }\r\n        ]);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Handle appointment booking by doctor ID and slot (supports \"5PM\", \"5 PM\", \"5:00PM\", etc.)\r\n    const bookingRegex = /book.*appointment.*doctor\\s*id\\s*(\\d+).*on\\s*(\\d{4}-\\d{2}-\\d{2})\\s*,?\\s*(\\d{1,2}(?::\\d{2})?\\s*(?:AM|PM))/i;\r\n    const bookingMatch = typeof input === \"string\" && input.match(bookingRegex);\r\n    if (bookingMatch) {\r\n      await handleDirectBooking(bookingMatch);\r\n      return;\r\n    }\r\n\r\n    // Handle awaiting booking confirmation\r\n    if (awaitingBooking && typeof input === \"string\") {\r\n      const answer = input.trim().toLowerCase();\r\n      if (answer === \"yes\" && suggestedSpecialist) {\r\n        setChat((prev) => [\r\n          ...prev,\r\n          { sender: \"bot\", text: `Booking an appointment with a ${suggestedSpecialist} for you...` },\r\n        ]);\r\n        await handleAppointmentBooking(suggestedSpecialist);\r\n        setAwaitingBooking(null);\r\n        setSuggestedSpecialist(null);\r\n        return;\r\n      }\r\n      if (answer === \"no\") {\r\n        setChat((prev) => [\r\n          ...prev,\r\n          { sender: \"bot\", text: \"Okay, I won't book an appointment. If you need anything else, just let me know!\" },\r\n        ]);\r\n        setAwaitingBooking(null);\r\n        setSuggestedSpecialist(null);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Handle awaiting symptoms\r\n    if (awaitingSymptoms) {\r\n      await analyzeSymptoms(input);\r\n      return;\r\n    }\r\n\r\n    // Symptom keyword detection\r\n    const symptomKeywords = [\r\n      \"fever\", \"cough\", \"cold\", \"headache\", \"pain\", \"sore throat\", \"vomit\", \r\n      \"nausea\", \"diarrhea\", \"chills\", \"fatigue\", \"rash\", \"dizzy\", \"breath\", \"congestion\"\r\n    ];\r\n    const lower = typeof input === \"string\" ? input.toLowerCase() : \"\";\r\n    if (symptomKeywords.some((kw) => lower.includes(kw))) {\r\n      await analyzeSymptoms(input);\r\n      return;\r\n    }\r\n\r\n    // Prescription text detection\r\n    const prescriptionKeywords = [\r\n      \"tablet\", \"capsule\", \"syrup\", \"medicine\", \"drug\", \"prescription\", \"dosage\", \r\n      \"take\", \"mg\", \"ml\", \"twice daily\", \"once daily\", \"before meals\", \"after meals\"\r\n    ];\r\n    if (typeof input === \"string\" && prescriptionKeywords.some((kw) => lower.includes(kw))) {\r\n      await explainPrescription(input);\r\n      return;\r\n    }\r\n\r\n    // Enhanced natural language processing with comprehensive Gemini parsing\r\n    if (typeof input === \"string\") {\r\n      // Get comprehensive parsing from Gemini\r\n      const geminiResult = await geminiParseInput(input, role);\r\n      \r\n      if (geminiResult) {\r\n        // Handle direct medicine addition with extracted data\r\n        if (geminiResult.intent === \"medicine_add\" && geminiResult.patient_identifier && geminiResult.medicines) {\r\n          await handleMedicineAdditionFromGemini(geminiResult);\r\n          return;\r\n        }\r\n        \r\n        // Handle patient lookup with extracted data\r\n        if (geminiResult.intent === \"patient_lookup\" && geminiResult.patient_identifier) {\r\n          await handlePatientLookupFromGemini(geminiResult);\r\n          return;\r\n        }\r\n        \r\n        // Handle direct appointment booking with full details\r\n        if (geminiResult.intent === \"book_appointment\" && geminiResult.doctor_id && geminiResult.date && geminiResult.time) {\r\n          const bookingMatch = [null, geminiResult.doctor_id.toString(), geminiResult.date, geminiResult.time];\r\n          await handleDirectBooking(bookingMatch);\r\n          return;\r\n        }\r\n        \r\n        // Handle symptom analysis with extracted symptoms\r\n        if (geminiResult.intent === \"symptom_check\" && geminiResult.symptoms) {\r\n          await analyzeSymptoms(geminiResult.symptoms);\r\n          return;\r\n        }\r\n        \r\n        // Handle prescription history with extracted parameters\r\n        if (geminiResult.intent === \"prescription_history\") {\r\n          await handlePrescriptionHistoryWithParams(geminiResult.count, geminiResult.timeframe);\r\n          return;\r\n        }\r\n      }\r\n      \r\n      // Enhanced intent detection for text input\r\n      const intentResult = await detectIntent(input);\r\n      if (intentResult) {\r\n        await handleUserInput(intentResult, false);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Default response\r\n    setChat((prev) => [\r\n      ...prev,\r\n      { sender: \"bot\", text: \"How can I help you today? You can:\\nâ€¢ Use the buttons below\\nâ€¢ Describe your symptoms\\nâ€¢ Type natural language requests like:\\n  - 'show my recent 5 prescriptions'\\n  - 'book appointment with cardiologist'\\n  - 'get patient john's medicine history'\" },\r\n    ]);\r\n  };\r\n\r\n  // Helper function to handle medicine addition from Gemini extraction\r\n  const handleMedicineAdditionFromGemini = async (geminiResult) => {\r\n    try {\r\n      const { patient_identifier, medicines } = geminiResult;\r\n      \r\n      // Resolve patient\r\n      let patientId, patientName;\r\n      if (/^\\d+$/.test(patient_identifier)) {\r\n        const patientResponse = await fetch(`http://localhost:3001/api/patients/${patient_identifier}`);\r\n        const patientData = await patientResponse.json();\r\n        if (!patientResponse.ok || !patientData.patient) {\r\n          setChat((prev) => [...prev, { sender: \"bot\", text: `Patient not found with ID: ${patient_identifier}` }]);\r\n          return;\r\n        }\r\n        patientId = parseInt(patient_identifier);\r\n        patientName = patientData.patient.full_name;\r\n      } else {\r\n        const lookupResponse = await fetch(`http://localhost:3001/api/patients/lookup/${patient_identifier}`);\r\n        const lookupData = await lookupResponse.json();\r\n        if (!lookupResponse.ok || lookupData.context.status !== \"found\") {\r\n          setChat((prev) => [...prev, { sender: \"bot\", text: `Patient not found: ${patient_identifier}` }]);\r\n          return;\r\n        }\r\n        patientId = lookupData.patient.id;\r\n        patientName = lookupData.patient.full_name;\r\n      }\r\n      \r\n      // Add medicines\r\n      let successCount = 0;\r\n      let failCount = 0;\r\n      const results = [];\r\n      \r\n      for (const medicine of medicines) {\r\n        try {\r\n          const response = await fetch(\"http://localhost:3001/api/prescriptions/add\", {\r\n            method: \"POST\",\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({\r\n              context: {\r\n                patient_id: patientId,\r\n                doctor_id: user?.id || 1,\r\n                medicine_name: medicine.name,\r\n                dosage: medicine.dosage,\r\n                duration: medicine.duration,\r\n                instructions: medicine.instructions || \"As prescribed by doctor\"\r\n              }\r\n            })\r\n          });\r\n          const data = await response.json();\r\n          \r\n          if (data.context && data.context.status === \"prescribed\") {\r\n            successCount++;\r\n            results.push(`âœ… ${medicine.name} - Added successfully`);\r\n          } else {\r\n            failCount++;\r\n            results.push(`âŒ ${medicine.name} - ${data.error || \"Failed to add\"}`);\r\n          }\r\n        } catch (error) {\r\n          failCount++;\r\n          results.push(`âŒ ${medicine.name} - Error adding medicine`);\r\n        }\r\n      }\r\n      \r\n      const summary = `Added ${successCount} medicine(s) for ${patientName} (${patient_identifier})${failCount > 0 ? `, ${failCount} failed` : ''}:\\n\\n${results.join('\\n')}`;\r\n      setChat((prev) => [...prev, { sender: \"bot\", text: summary }]);\r\n      \r\n    } catch (error) {\r\n      setChat((prev) => [...prev, { sender: \"bot\", text: \"Error processing medicine addition.\" }]);\r\n    }\r\n  };\r\n\r\n  // Helper function to handle patient lookup from Gemini extraction\r\n  const handlePatientLookupFromGemini = async (geminiResult) => {\r\n    try {\r\n      const { patient_identifier, action = \"view_patient_medicines\" } = geminiResult;\r\n      \r\n      // Resolve patient\r\n      let patientId, patientName;\r\n      if (/^\\d+$/.test(patient_identifier)) {\r\n        const patientResponse = await fetch(`http://localhost:3001/api/patients/${patient_identifier}`);\r\n        const patientData = await patientResponse.json();\r\n        if (!patientResponse.ok || !patientData.patient) {\r\n          setChat((prev) => [...prev, { sender: \"bot\", text: `Patient not found with ID: ${patient_identifier}` }]);\r\n          return;\r\n        }\r\n        patientId = parseInt(patient_identifier);\r\n        patientName = patientData.patient.full_name;\r\n      } else {\r\n        const lookupResponse = await fetch(`http://localhost:3001/api/patients/lookup/${patient_identifier}`);\r\n        const lookupData = await lookupResponse.json();\r\n        if (!lookupResponse.ok || lookupData.context.status !== \"found\") {\r\n          setChat((prev) => [...prev, { sender: \"bot\", text: `Patient not found: ${patient_identifier}` }]);\r\n          return;\r\n        }\r\n        patientId = lookupData.patient.id;\r\n        patientName = lookupData.patient.full_name;\r\n      }\r\n      \r\n      // Execute the requested action - show medicine history\r\n      const response = await fetch(`http://localhost:3001/api/patients/${patientId}/prescription-history`);\r\n      const data = await response.json();\r\n      const prescriptions = data.prescriptions || [];\r\n      \r\n      if (prescriptions.length > 0) {\r\n        const prescriptionsList = prescriptions.map(presc => {\r\n          const date = new Date(presc.prescribed_date);\r\n          const doctorName = presc.doctor_name ? `by Dr. ${presc.doctor_name}` : 'by Unknown Doctor';\r\n          return `ðŸ“œ ${presc.medicine_name} (${presc.dosage}) - ${presc.duration}\\n   Prescribed on ${date.toLocaleDateString()} ${doctorName}\\n   Status: ${presc.status}\\n   Instructions: ${presc.instructions || 'None'}`;\r\n        }).join('\\n\\n');\r\n        \r\n        setChat((prev) => [\r\n          ...prev,\r\n          { sender: \"bot\", text: `Medicine history for ${patientName} (${patient_identifier}):\\n\\n${prescriptionsList}` },\r\n        ]);\r\n      } else {\r\n        setChat((prev) => [\r\n          ...prev,\r\n          { sender: \"bot\", text: `No prescription history found for ${patientName} (${patient_identifier}).` },\r\n        ]);\r\n      }\r\n      \r\n    } catch (error) {\r\n      setChat((prev) => [...prev, { sender: \"bot\", text: \"Error processing patient lookup.\" }]);\r\n    }\r\n  };\r\n\r\n  // Helper function to handle prescription history with specific parameters\r\n  const handlePrescriptionHistoryWithParams = async (count, timeframe) => {\r\n    try {\r\n      const patient_id = user?.id || 1;\r\n      \r\n      // Determine limit based on parameters\r\n      let limit;\r\n      if (count) {\r\n        limit = parseInt(count, 10);\r\n      } else if (timeframe === \"all\") {\r\n        limit = 1000;\r\n      } else {\r\n        limit = 10; // default for \"recent\" or null\r\n      }\r\n      \r\n      // Ensure reasonable limits\r\n      if (limit > 100) limit = 100;\r\n      if (limit < 1) limit = 10;\r\n      \r\n      const response = await fetch(`http://localhost:3001/api/patients/${patient_id}/prescription-history?limit=${limit}`);\r\n      const data = await response.json();\r\n      \r\n      // Handle MCP-style response\r\n      const prescriptions = data.prescriptions || [];\r\n      if (prescriptions.length > 0) {\r\n        const prescriptionsList = prescriptions.map(presc => {\r\n          const date = new Date(presc.prescribed_date);\r\n          const doctorName = presc.doctor_name ? `by Dr. ${presc.doctor_name}` : 'by Unknown Doctor';\r\n          return `ðŸ“œ ${presc.medicine_name} (${presc.dosage}) - ${presc.duration}\\n   Prescribed on ${date.toLocaleDateString()} ${doctorName}\\n   Status: ${presc.status}`;\r\n        }).join('\\n\\n');\r\n        \r\n        let displayText;\r\n        if (count) {\r\n          displayText = `Your last ${prescriptions.length} prescription${prescriptions.length !== 1 ? 's' : ''}:\\n\\n${prescriptionsList}`;\r\n        } else if (timeframe === \"all\") {\r\n          displayText = `All your prescriptions (${prescriptions.length} total):\\n\\n${prescriptionsList}`;\r\n        } else {\r\n          displayText = `Your recent prescriptions (last ${prescriptions.length}):\\n\\n${prescriptionsList}`;\r\n        }\r\n        \r\n        setChat((prev) => [\r\n          ...prev,\r\n          { sender: \"bot\", text: displayText },\r\n        ]);\r\n      } else {\r\n        setChat((prev) => [\r\n          ...prev,\r\n          { sender: \"bot\", text: data.message || \"No prescription history found.\" },\r\n        ]);\r\n      }\r\n    } catch (error) {\r\n      setChat((prev) => [\r\n        ...prev,\r\n        { sender: \"bot\", text: \"Error fetching prescription history.\" },\r\n      ]);\r\n    }\r\n  };\r\n\r\n  // Helper function to handle appointment booking\r\n  const handleAppointmentBooking = async (specialist = null) => {\r\n    try {\r\n      setChat((prev) => [\r\n        ...prev,\r\n        { sender: \"bot\", text: specialist ? `Looking for available ${specialist} doctors...` : \"Looking for available doctors...\" }\r\n      ]);\r\n\r\n      const url = specialist \r\n        ? `http://localhost:3001/api/doctors/available-slots?specialist=${specialist}`\r\n        : `http://localhost:3001/api/doctors/available-slots`;\r\n      \r\n      const response = await fetch(url);\r\n      const data = await response.json();\r\n      \r\n      if (data.doctors && data.doctors.length > 0) {\r\n        setDoctorListCache(data.doctors);\r\n        \r\n        const doctorsList = data.doctors.map(doc => {\r\n          let availabilityText = \"\";\r\n          if (doc.slots && Object.keys(doc.slots).length > 0) {\r\n            const availableDays = Object.keys(doc.slots)\r\n              .filter(day => doc.slots[day] && doc.slots[day].length > 0)\r\n              .map(day => {\r\n                const slots = doc.slots[day];\r\n                const timeRange = `${slots[0].time} - ${slots[slots.length - 1].time}`;\r\n                return `${day}: ${timeRange}`;\r\n              });\r\n            \r\n            availabilityText = availableDays.length > 0 \r\n              ? `\\n   Available: ${availableDays.join(\", \")}`\r\n              : \"\\n   No availability set\";\r\n          } else {\r\n            availabilityText = \"\\n   No availability set\";\r\n          }\r\n          \r\n          return `Dr. ${doc.full_name} (ID: ${doc.id}) - ${doc.specialization}${availabilityText}`;\r\n        }).join(\"\\n\\n\");\r\n        \r\n        setChat((prev) => [\r\n          ...prev,\r\n          { \r\n            sender: \"bot\", \r\n            text: `Available ${specialist || ''}doctors:\\n\\n${doctorsList}\\n\\nTo book, you can either:\\n1. Type just the doctor ID number (e.g., \"1\" for Dr. Smith)\\n2. Type: \"book my appointment for doctor id [ID] on YYYY-MM-DD, HH:MM AM/PM\"\\n\\nExample: \"book my appointment for doctor id 1 on 2025-07-15, 10:00 AM\"` \r\n          }\r\n        ]);\r\n      } else {\r\n        setChat((prev) => [\r\n          ...prev,\r\n          { sender: \"bot\", text: `Sorry, no ${specialist || ''}doctors are available at the moment.` }\r\n        ]);\r\n      }\r\n    } catch (error) {\r\n      setChat((prev) => [\r\n        ...prev,\r\n        { sender: \"bot\", text: \"Error fetching doctors. Please try again later.\" }\r\n      ]);\r\n    }\r\n  };\r\n\r\n  // Helper function to handle direct booking\r\n  const handleDirectBooking = async (bookingMatch) => {\r\n    const doctorId = parseInt(bookingMatch[1], 10);\r\n    const dateStr = bookingMatch[2];\r\n    const slot = bookingMatch[3].toUpperCase();\r\n\r\n    // If no doctor cache, fetch the doctor info directly\r\n    let doctor = doctorListCache?.find(d => d.id === doctorId);\r\n    \r\n    if (!doctor) {\r\n      try {\r\n        const response = await fetch(`http://localhost:3001/api/doctors/available-slots`);\r\n        const data = await response.json();\r\n        \r\n        if (data.doctors && data.doctors.length > 0) {\r\n          setDoctorListCache(data.doctors);\r\n          doctor = data.doctors.find(d => d.id === doctorId);\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Error fetching doctor info:\", error);\r\n      }\r\n    }\r\n\r\n    if (!doctor) {\r\n      setChat((prev) => [\r\n        ...prev,\r\n        { sender: \"bot\", text: \"Invalid doctor selection. Please try again or use the Book Appointment button to see available doctors.\" }\r\n      ]);\r\n      return;\r\n    }\r\n\r\n    const dayOfWeek = new Date(dateStr).toLocaleString(\"en-US\", { weekday: \"long\" });\r\n    \r\n    // Better slot normalization to handle leading zeros and missing minutes\r\n    const normalizeSlot = (timeStr) => {\r\n      // First normalize the format to always include minutes\r\n      const timeRegex = /^(\\d{1,2})(?::(\\d{2}))?\\s*(AM|PM)$/i;\r\n      const match = timeStr.match(timeRegex);\r\n      \r\n      if (match) {\r\n        const hour = match[1];\r\n        const minute = match[2] || '00'; // Default to '00' if no minutes\r\n        const ampm = match[3].toUpperCase();\r\n        return `${hour}:${minute}${ampm}`;\r\n      }\r\n      \r\n      // Fallback to original normalization\r\n      return timeStr.replace(/\\s+/g, '').toUpperCase().replace(/^0+(\\d)/, '$1');\r\n    };\r\n    \r\n    const normalizedSlot = normalizeSlot(slot);\r\n    const availableSlots = (doctor.slots[dayOfWeek] || [])\r\n      .map(s => normalizeSlot(s.time));\r\n\r\n    // Check slot availability\r\n    console.log(\"=== SLOT NORMALIZATION DEBUG ===\");\r\n    console.log(\"User input slot:\", slot);\r\n    console.log(\"Normalized user slot:\", normalizedSlot);\r\n    console.log(\"Available slots raw:\", doctor.slots[dayOfWeek]);\r\n    console.log(\"Available slots normalized:\", availableSlots);\r\n    console.log(\"Match found:\", availableSlots.includes(normalizedSlot));\r\n    \r\n    if (!availableSlots.includes(normalizedSlot)) {\r\n      const availableDaysText = Object.keys(doctor.slots)\r\n        .filter(day => doctor.slots[day] && doctor.slots[day].length > 0)\r\n        .map(day => `${day}: ${doctor.slots[day].map(s => s.time).join(', ')}`)\r\n        .join('\\n   ');\r\n      \r\n      setChat((prev) => [\r\n        ...prev,\r\n        { \r\n          sender: \"bot\", \r\n          text: `Selected slot (${slot}) is not available on ${dayOfWeek}.\\n\\nDr. ${doctor.full_name} is available:\\n   ${availableDaysText || 'No availability set'}\\n\\nPlease choose an available slot.`\r\n        }\r\n      ]);\r\n      return;\r\n    }\r\n\r\n    // Check if slot is already booked\r\n    try {\r\n      const appointmentsRes = await fetch(`http://localhost:3001/api/doctors/appointments/${doctor.id}?date=${dateStr}`);\r\n      const appointmentsData = await appointmentsRes.json();\r\n      \r\n      const bookedSlots = new Set();\r\n      if (appointmentsData.appointments) {\r\n        appointmentsData.appointments.forEach(appt => {\r\n          const apptDate = new Date(appt.appointment_time);\r\n          const hour = apptDate.getHours();\r\n          let displayHour = hour % 12 === 0 ? 12 : hour % 12;\r\n          let ampm = hour < 12 ? \"AM\" : \"PM\";\r\n          let slotStr = normalizeSlot(`${displayHour}:00 ${ampm}`);\r\n          bookedSlots.add(slotStr);\r\n        });\r\n      }\r\n\r\n      if (bookedSlots.has(normalizedSlot)) {\r\n        setChat((prev) => [\r\n          ...prev,\r\n          { sender: \"bot\", text: \"This slot is already booked. Please choose another slot.\" }\r\n        ]);\r\n        return;\r\n      }\r\n\r\n      // Parse and book appointment with improved time parsing\r\n      const parseTimeSlot = (timeSlot) => {\r\n        // Handle formats: \"5PM\", \"5 PM\", \"5:00PM\", \"5:00 PM\", \"05:00 PM\", etc.\r\n        const timeRegex = /^(\\d{1,2})(?::(\\d{2}))?\\s*(AM|PM)$/i;\r\n        const match = timeSlot.match(timeRegex);\r\n        \r\n        if (!match) {\r\n          throw new Error(`Invalid time format: ${timeSlot}`);\r\n        }\r\n        \r\n        let hour = parseInt(match[1], 10);\r\n        const minute = match[2] ? parseInt(match[2], 10) : 0; // Default to 0 if no minutes provided\r\n        const ampm = match[3].toUpperCase();\r\n        \r\n        if (ampm === \"PM\" && hour !== 12) hour += 12;\r\n        if (ampm === \"AM\" && hour === 12) hour = 0;\r\n        \r\n        return { hour, minute };\r\n      };\r\n      \r\n      let appointment_time;\r\n      try {\r\n        const { hour, minute } = parseTimeSlot(slot);\r\n        appointment_time = `${dateStr} ${hour.toString().padStart(2, \"0\")}:${minute.toString().padStart(2, \"0\")}:00`;\r\n        \r\n        console.log(\"Parsed time:\", { originalSlot: slot, hour, minute, appointment_time });\r\n      } catch (parseError) {\r\n        setChat((prev) => [\r\n          ...prev,\r\n          { sender: \"bot\", text: `Invalid time format. Please use format like \"5PM\", \"5:00PM\", or \"5:00 PM\"` }\r\n        ]);\r\n        return;\r\n      }\r\n\r\n      const patient_id = user?.id || 1;\r\n      const bookRes = await fetch(\"http://localhost:3001/api/doctors/book-appointment\", {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify({\r\n          context: {\r\n            patient_id,\r\n            doctor_id: doctorId,\r\n            appointment_time\r\n          }\r\n        }),\r\n      });\r\n\r\n      const bookData = await bookRes.json();\r\n      if (bookRes.ok && bookData.context && bookData.context.status === \"booked\") {\r\n        setChat((prev) => [\r\n          ...prev,\r\n          {\r\n            sender: \"bot\",\r\n            text: `âœ… Appointment booked with Dr. ${doctor.full_name} on ${dateStr} at ${slot}.`,\r\n          },\r\n        ]);\r\n      } else {\r\n        setChat((prev) => [\r\n          ...prev,\r\n          { sender: \"bot\", text: bookData.message || bookData.error || \"Failed to book appointment.\" },\r\n        ]);\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Error in handleDirectBooking:\", error);\r\n      setChat((prev) => [\r\n        ...prev,\r\n        { sender: \"bot\", text: \"Error processing booking. Please try again.\" }\r\n      ]);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <ChatWindow\r\n      messages={chat}\r\n      buttons={buttons}\r\n      onUserInput={handleUserInput}\r\n      onFileUpload={handleFileUpload}\r\n      isProcessing={isAnalyzing}\r\n    />\r\n  );\r\n};\r\n\r\nexport default SmartTriage;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}